@prefix dfc:   <http://www.virtual-assembly.org/DataFoodConsortium/BusinessOntology#> .
@prefix owl:   <http://www.w3.org/2002/07/owl#> .
@prefix org:   <http://www.w3.org/ns/org#> .
@prefix xsd:   <http://www.w3.org/2001/XMLSchema#> .
@prefix dtype: <http://www.linkedmodel.org/schema/dtype#> .
@prefix skos:  <http://www.w3.org/2004/02/skos/core#> .
@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .
@prefix geo:   <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix vf:    <https://w3id.org/valueflows#> .
@prefix sh:    <http://www.w3.org/ns/shacl#> .
@prefix om2:   <http://www.ontology-of-units-of-measure.org/resource/om-2/> .
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix time:  <http://www.w3.org/2006/time#> .
@prefix vs:    <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .
@prefix om2: <http://www.ontology-of-units-of-measure.org/resource/om-2/> .
@prefix : <https://w3id.org/valueflows-shacl#> .
@prefix ex: <http://example.org/ns#> .


vf: 
    sh:declare [
        sh:prefix "om2" ;
        sh:namespace "http://www.ontology-of-units-of-measure.org/resource/om-2/" ;
    ] ;
    sh:declare [
        sh:prefix "vf" ;
        sh:namespace "https://w3id.org/valueflows#" ;
    ] ;
    sh:declare [
        sh:prefix "vfs" ;
        sh:namespace "https://w3id.org/valueflows-shacl#" ;
    ] ;
    sh:declare [
        sh:prefix "owl" ;
        sh:namespace "http://www.w3.org/2002/07/owl#" ;
    ] ;
    sh:declare [
        sh:prefix "rdf" ;
        sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ;
    ] ;
    sh:declare [
        sh:prefix "xsd" ;
        sh:namespace "http://www.w3.org/2001/XMLSchema#" ;
    ] ;    
    .




:EconomicEventShape
        a               sh:NodeShape ;
        sh:targetClass vf:EconomicEvent ;
        sh:property :RequireProviderShape ;
        sh:property :RequireReceiverShape ;
        sh:property :ActionShape ;
        sh:property :ResourceInventoriedAsShape ;
        sh:property :ToResourceInventoriedAsShape ;
        sh:property :ResourceQuantityShape ;
        
        .

:EconomicResourceShape
        a               sh:NodeShape ;
        sh:targetClass  vf:EconomicResource ;
        sh:property     :AccountingQuantityShape ;
        sh:property     :OnhandQuantityShape ;
        sh:property     :ResourceClassifiedAsShape ;
        sh:property     :TrackingIdentifierShape ;
        sh:property     :ConformsToShape ;
        sh:property     :ContainedInShape ;
        sh:property     :CurrentLocationShape ;
        sh:property     :PrimaryAccountableShape ;
# ignoring for now:         
#       sh:property     :lotShape ; unclear: what is product batch?
#       sh:property     :stageShape ;
#       sh:property     :stateShape ;
#       sh:property     :TrackingIdentifierShape ;
    .
:PrimaryAccountableShape
        a               sh:PropertyShape ;
        sh:path         vf:primaryAccountable ;
        sh:class        foaf:Agent ;
        sh:maxCount     1 ;
        .


:CurrentLocationShape
        a               sh:PropertyShape ;
        sh:path         vf:currentLocation ;
        sh:maxCount     1 ;
        .

:ConformsToShape 
        a               sh:PropertyShape ;
        sh:path         vf:conformsTo ;
        sh:class        vf:ResourceSpecification ;
        .

:ContainedInShape
        a               sh:PropertyShape ;
        sh:path         vf:containedIn ;
        sh:class        vf:EconomicResource ;
        .

:TrackingIdentifierShape
        a               sh:PropertyShape ;
        sh:path         vf:trackingIdentifier ;
        sh:nodeKind     sh:IRIOrLiteral ;
        sh:maxCount     1 ;
        .

:ResourceClassifiedAsShape
        a               sh:PropertyShape ;
        sh:path         vf:resourceClassifiedAs ;
        sh:nodeKind     sh:IRI ;        
        .

:AccountingQuantityShape 
        a               sh:PropertyShape ;
        sh:path         vf:accountingQuantity ; 
        sh:node         :QuantityNodeShape ;
        sh:maxCount     1 ;
        sh:nodeKind     sh:BlankNodeOrIRI ;
        .

:QuantityNodeShape
        a               sh:NodeShape ;
        sh:property [
            sh:path om2:hasUnit ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path om2:hasNumericalValue ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:nodeKind sh:Literal ;
            sh:or (
                [ sh:datatype xsd:int ]
                [ sh:datatype xsd:integer ]
                [ sh:datatype xsd:double ]
                [ sh:datatype xsd:float ]
                [ sh:datatype xsd:decimal ]
                [ sh:datatype xsd:long ]
                [ sh:datatype xsd:short ]
            )
        ]
        .

:OnhandQuantityShape 
        a               sh:PropertyShape ;
        sh:node         :QuantityNodeShape ;
        sh:path         vf:onhandQuantity ;
        sh:maxCount     1 ;
        sh:nodeKind     sh:BlankNodeOrIRI ;         
        .

:ResourceQuantityShape
        a               sh:PropertyShape ;
        sh:node         :QuantityNodeShape ;
        sh:path         vf:resourceQuantity ;
        .

:ResourceInventoriedAsShape
        a               sh:PropertyShape ;
        sh:class        vf:EconomicResource ;
        sh:path         vf:resourceInventoriedAs ;
        sh:maxCount     1 ;
        .

:ToResourceInventoriedAsShape
        a               sh:PropertyShape ;
        sh:class        vf:EconomicResource ;
        sh:path         vf:toResourceInventoriedAs ;
        sh:maxCount     1 ;
        .


:RequireProviderShape
        a               sh:PropertyShape ;
        sh:path         vf:provider;
        sh:class        foaf:Agent ;
        sh:maxCount     1 ;
        sh:minCount     1 ;
        sh:nodeKind     sh:IRI ;
        .

:RequireReceiverShape
        a               sh:PropertyShape ;
        sh:path         vf:provider;
        sh:class        foaf:Agent ;
        sh:maxCount     1 ;
        sh:minCount     1 ;
        sh:nodeKind     sh:IRI ;
        .

:ActionShape
        a               sh:PropertyShape ;
        sh:path         vf:action ;
        sh:class        vf:Action ;
        sh:maxCount     1 ;
        sh:minCount     1 ;
        .      

# If an EconomicEvent references two EconomicResources, their quantities
# must be measured with the same units. (This constraint may turn out to
# be too strict - eg when splitting one big resource (measured in tons) 
# into much smaller resources (measured in kilograms). 
:RequireCompatibleQuantitiesShape
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:resourceQuantity ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:node :ToResourceInventoriedAsForbiddenShape ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:select """
                SELECT ?this ("The measurement units of this EconomicEvent and its EconomicResource do not match"  as ?message ) 
                WHERE {
                    ?this 
                        vf:resourceQuantity/om2:hasUnit                         ?evUnit  ;
                        vf:resourceInventoriedAs/vf:onhandQuantity/om2:hasUnit  ?resUnit  .     
                    FILTER (?resUnit != ?evUnit)
                }
            """ 
        ] ;
    .


# If an EconomicEvent references two EconomicResources, their quantities
# must be measured with the same units. (This constraint may turn out to
# be too strict - eg when splitting one big resource (measured in tons) 
# into much smaller resources (measured in kilograms). 
:RequireCompatibleQuantitiesShape_toResource
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:resourceQuantity ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:node :ToResourceInventoriedAsRequiredShape ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:select """
                SELECT ?this (CONCAT("The EconomicResources connected by this event (using ", 
                                STR(?evUnit)," for units) must use the same units of measurement for ",
                                "their vf:onhandQuantity values, but units are ", STR(?resUnit), 
                                " and ", STR(?toResUnit) ) as ?message ) 
                WHERE {
                    ?this 
                        vf:resourceQuantity/om2:hasUnit                          ?evUnit ;
                        vf:resourceInventoriedAs/vf:onhandQuantity/om2:hasUnit   ?resUnit ;     
                        vf:toResourceInventoriedAs/vf:onhandQuantity/om2:hasUnit ?toResUnit .
                    FILTER (?resUnit != ?toResUnit || ?evUnit != ?resUnit)
                }
            """ ; 
        ] ;
    .

# Some events decrement a resource's `vf:onhandQuantity`. This
# rule ensures that the resource has at least that quantity.
:RequireSufficientQuantityForResourceDecrementShape
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue );
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:select """
                SELECT ?this (CONCAT(
                    "The EconomicEvent, ", ?this, " decrements by ", ?evQuantity, 
                    ", but the EconomicResource, ", ?res, ", only has ", ?resQuantity, ".") 
                    as ?message ) 
                WHERE {
                    ?this 
                        vf:resourceQuantity/om2:hasNumericalValue 
                                        ?evQuantity ;
                        vf:resourceInventoriedAs/vf:onhandQuantity/om2:hasNumericalValue   
                                        ?resQuantity;     
                    FILTER (?resQuantity < ?evQuantity )
                }
            """ ; 
        ] ;
    .


# If an EconomicEvent references two EconomicResources, their quantities
# must be measured with the same units. (This constraint may turn out to
# be too strict - eg when splitting one big resource (measured in tons) 
# into much smaller resources (measured in kilograms). 
:RequireSameQuantitiesOnEventAndResource
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:resourceQuantity ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:node :ToResourceInventoriedAsForbiddenShape ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:select """
                SELECT ?this ("The quantities of this EconomicEvent and its EconomicResource do not match"  as ?message ) 
                WHERE {
                    ?this 
                        vf:resourceQuantity/om2:hasNumericalValue                         ?evQuantity  ;
                        vf:resourceInventoriedAs/vf:onhandQuantity/om2:hasNumericalValue  ?resQuantity  .     
                    FILTER (?resQuantity != ?evQuantity)
                }
            """ 
        ] ;
    .    

:RequireLocationChangeShape_toResource
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:action ; 
            sh:hasValue vf:move ; #TODO check: only with 'move' action?
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path ( vf:resourceInventoriedAs vf:currentLocation );
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path ( vf:toResourceInventoriedAs vf:currentLocation );
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:message "Resources/Event locations inappropriate for location change" ;
            sh:select """
                SELECT ?this 
                WHERE {
                    ?this 
                        vf:atLocation ?evLoc ;
                        vf:resourceInventoriedAs ?res ;
                        vf:toResourceInventoriedAs ?toRes .
                    ?res vf:currentLocation ?fromLoc .
                    ?toRes vf:currentLocation ?toLoc .
                    OPTIONAL {
                        ?next   vf:previousState ?res ;
                                vf:currentLocation ?nextfromLoc .
                    }
                    OPTIONAL {
                        ?toNext vf:previousState ?toRes ;
                                vf:currentLocation ?nextToLoc .
                    }
                    FILTER (
                           ?evLoc = ?fromLoc 
                        || ?evLoc != ?toLoc 
                        || (BOUND(?nextfromLoc) && ?nextfromLoc != ?fromLoc)
                        || (BOUND(?nextToLoc) && ?nextToLoc != ?toLoc)
                    )
                }
            """ ; 
        ] ;
    .
# - Event's vf:atLocation must differ from resource's vf:currentLocation
# - if present, next state's vf:currentLocation must be event's vf:atLocation
:RequireLocationChangeShape
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:atLocation ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path ( vf:resourceInventoriedAs vf:currentLocation );
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:message "Event's vf:atLocation must be different from resource's vf:currentLocation" ;
            sh:select """
                SELECT ?this 
                WHERE {
                    ?this 
                        vf:atLocation                          ?evLoc .
                        ?this vf:resourceInventoriedAs ?res .
                        ?res  vf:currentLocation ?fromLoc ;
                    .
                    OPTIONAL {
                        ?next vf:previousState ?res ;
                              vf:currentLocation ?nextLoc ;
                    }
                    FILTER ( ?evLoc = ?fromLoc || ( BOUND(?nextLoc) && ?evLoc != ?nextLoc) )
                }
            """ ; 
        ] ;
    .

:ResourceInventoriedAsRequiredShape
        a           sh:NodeShape ;
        sh:property [
            sh:path vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "This event must reference an inventoried resource as its source using 'vf:resourceInventoriedAs'" ;
        ] ;
        .

:ToResourceInventoriedAsRequiredShape
        a           sh:NodeShape ;
        sh:property [
            sh:path vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "This event must reference an inventoried resource as its target using 'vf:toResourceInventoriedAs'" ;
        ] ;
        .

:ToResourceInventoriedAsForbiddenShape
        a           sh:NodeShape ;
        sh:property [
            sh:path vf:toResourceInventoriedAs ;
            sh:maxCount 0 ;
            sh:message "This event must not reference an inventoried resource as its target using 'vf:toResourceInventoriedAs'" ;
        ] ;
        .

:RequireSamePrimaryAccountableShape_toResource
        a           sh:NodeShape ;
        sh:class    vf:EconomicEvent ;
        sh:node     :ToResourceInventoriedAsRequiredShape ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:message "`vf:primaryAccountable` values of the resources referenced by the event must not be different." ;
            sh:select """ 
            SELECT ?this 
            WHERE {
                ?this   vf:resourceInventoriedAs ?res ;
                        vf:toResourceInventoriedAs ?toRes .
                ?res    vf:primaryAccountable   ?agent .
                ?toRes  vf:primaryAccountable   ?toAgent .
                FILTER (?agent != ?toAgent)
            }
            """;
        ] .

:EventStateChangedByActionTarget
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?event   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    ?this ;
                    vf:action                   ?action .
                ?this vf:previousState ?prev .
                    .
                FILTER NOT EXISTS {
                    ?event vf:toResourceInventoriedAs []  
                } 
			}
			""" ;
        .



###############################################################################
#                   Some Utilities
###############################################################################

# SPARQLFunction for identifying EconomicEvents by properties of their vf:action
# i.e. checks if `$parEvent/vf:action/$parActionProperty = $parValue`
:EventHasActionPropertyValueFunction
        a sh:SPARQLFunction ;
        rdfs:comment "True if the specified event has an action with the specified property value" ;
        sh:labelTemplate "True for events with `vf:action/{$parActionProperty} = $parValue`. " ;
        sh:parameter [
            sh:path :parEvent ;
            sh:nodeKind sh:IRI ;
            sh:description "The event to check" ;
        ] ;
        sh:parameter [
            sh:path :parActionProperty ;
            sh:nodeKind sh:IRI ;
            sh:description "The action property to check" ;
        ] ;
        sh:parameter [
            sh:path :parValue ;
            sh:nodeKind sh:IRI ;
            sh:description "The value to compare to" ;
        ] ;
        sh:prefixes vf: ;
        sh:returnType xsd:boolean ;
        sh:ask """
            ASK  
            WHERE {
                $parEvent 
                    a                       vf:EconomicEvent ;
                    vf:action               ?action ;
                .
                ?action     
                    $parActionProperty      $parValue ;
                .
                BIND (?parEvent as ?this)
            }
        """ ;
        .


# SPARQLTargetType for selecting EconomicEvents by properties of their vf:action
# i.e. checking for [value] of [property] in event/vf:action/[property] = [value]
:EventHasActionPropertyValueTarget
        a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
        rdfs:comment "Selects events that have the specified action property value" ;
        sh:labelTemplate "All events with `vf:action/{$parActionProperty} = $parValue`. " ;
        sh:parameter [
            sh:path :parActionProperty ;
            sh:nodeKind sh:IRI ;
            sh:description "The action property to check" ;
        ] ;
        sh:parameter [
            sh:path :parValue ;
            sh:nodeKind sh:IRI ;
            sh:description "The Value to check for" ;
        ] ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this 
            WHERE {
                ?this 
                    a                       vf:EconomicEvent ;
                    vf:action               ?action ;
                .
                ?action     
                    $parActionProperty      $parValue ;
                .
            }
        """ ;
        .

# SPARQLTarget shape for selecting current events
:CurrentEventsTargetByActionProp
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parEventActionProperty ;
            sh:nodeKind sh:IRI ;
        ] ;
        sh:parameter [
            sh:path :parEventActionPropertyValue ;
            sh:nodeKind sh:IRI ;
        ] ;         
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    ?res ;
                    vf:action                   ?action ;
                    .
                ?action 
                    ?parEventActionProperty ?parEventActionPropertyValue .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriedAs ?toRes 
                }
                FILTER NOT EXISTS {
                    ?any1 vf:previousState ?res 
                } 
			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - all events 
#   - by action
#   - that do not have a toResourceIA
:EventsTarget_noToResource
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    [] ;
                .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriedAs  []               
                }
 			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - current events 
#   - by action
#   - that do not have a toResourceIA
:CurrentEventsTarget
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    ?res ;
                    vf:action                   ?parAction ;
                    .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriedAs []
                }
                FILTER NOT EXISTS {
                    [] vf:previousState ?res 
                } 
			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - all events 
#   - by action
#   - that have a toResourceIA
:EventsTarget_toResource
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    [] ;
                    vf:toResourceInventoriedAs  [] ;
                    .
 			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - current events 
#   - by action
#   - that have a toResourceIA
:CurrentEventsTarget_toResource
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    ?res ;
                    vf:toResourceInventoriedAs  ?toRes ;
                    vf:action                   ?parAction ;
                    .
                FILTER NOT EXISTS {
                    [] vf:previousState ?toRes 
                }
                FILTER NOT EXISTS {
                    [] vf:previousState ?res 
                } 
			}
			""" ;
        .

:EconomicEventHasTwoEconomicResourcesShape
    a           sh:NodeShape ;
    sh:class    vf:EconomicEvent ;
    sh:property [
        sh:path     vf:resourceInventoriedAs ;
        sh:class    vf:EconomicResource ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    sh:property [
        sh:path     vf:toResourceInventoriedAs ;
        sh:class    vf:EconomicResource ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    .

###############################################################################
#                   Calculation of EcononomicEvents' effects
###############################################################################


###############################################################################
#                       Events with action `vf:move` 
###############################################################################

## `vf:move` connected to only one resource

# Invariants for move actions with `vf:resourceInventoriedAs` and NO `vf:toResourceInventoriedAs`:
# - The event must have different `vf:atLocation` value than the resource's `vf:currentLocation` 
# - The event must have a quantity that must be equal to the resource's quantity
# - If the event is not current, the resource states must differ by vf:currentLocation
:EventShape_move
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:move
        ] ;
        :constantResourceProperty vf:primaryAccountable ;
        :constantResourceProperty vf:resourceClassifiedAs ;
        :constantResourceProperty vf:trackingIdentifier ;
        #:constantResourceProperty vf:onhandQuantity ;
        #:constantResourceProperty vf:accountingQuantity ;
        #sh:property [
        #    sh:path vf:atLocation ;
        #    :sameAsNextResourceProperty vf:currentLocation ;
        #    sh:minCount 1 ;
        #    sh:maxCount 1 ;
        #] ;
        sh:expression [
            sh:message "Event quantity is not identical to next state onhand quantity" ;
            :or (
                [ :notBound ( [ sh:path ( vf:resourceInventoriedAs [ sh:inversePath vf:previousState ] ) ] ) ]
                [ :and (
                    [ :IRIOrLiteralEquals ( 
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ] 
                        [ sh:path ( vf:resourceInventoriedAs [ sh:inversePath vf:previousState ] vf:onhandQuantity om2:hasUnit ) ]
                    )]    
                    [ :IRIOrLiteralEquals ( 
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ] 
                        [ sh:path ( vf:resourceInventoriedAs [ sh:inversePath vf:previousState ] vf:onhandQuantity om2:hasNumericalValue ) ]
                    )]
                )]
            )] ;

        sh:expression [
            :or (
                [ :notBound ( [ sh:path ( vf:resourceInventoriedAs [ sh:inversePath vf:previousState ] ) ] ) ]
                [ :IRIOrLiteralEquals ( 
                    [ sh:path vf:atLocation ] 
                    [ sh:path ( vf:resourceInventoriedAs [ sh:inversePath vf:previousState ] vf:currentLocation ) ]
                )]
                [ :deepEquals4 ( 
                    [ sh:path vf:atLocation ] 
                    [ sh:path ( vf:resourceInventoriedAs [ sh:inversePath vf:previousState ] vf:currentLocation ) ]
                )]    
            )
        ] ;

        sh:node :RequireSameQuantitiesOnEventAndResource ;
        .

:notBound
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :node ;
        sh:optional false ;
    ] ;
    sh:select """
    SELECT (!BOUND(?node) as ?result) 
    WHERE {}
    """ ;
    .

:bound 
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :node ;
        sh:optional false ;
    ] ;
    sh:select """
    SELECT (BOUND(?node) as ?result) 
    WHERE {}
    """ ;
    .

:or 
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op3 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op4 ;
        sh:optional true ;
    ] ;
    sh:select """
    SELECT ( ?op1 || ?op2 || ?op3 || ?op4 as ?result) 
    WHERE {}
    """;
    .

:and 
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op3 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op4 ;
        sh:optional true ;
    ] ;
    sh:select """
    SELECT ( (!BOUND(?op1) || ?op1) 
          && (!BOUND(?op2) || ?op2)
          && (!BOUND(?op3) || ?op3) 
          && (!BOUND(?op4) || ?op4) as ?result) 
    WHERE {}
    """;
    .

:not 
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
    ] ;
    sh:select """
    SELECT ( ! ?op1 as ?result) 
    WHERE {}
    """;
    .


:IRIOrLiteralEquals
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:order 1 ;
        sh:path :expected ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 2 ;
        sh:path :actual ;
        sh:optional false ;
    ] ;
    sh:select """
        SELECT (
                !ISBLANK(?actual) 
                && !ISBLANK(?expected) 
                && ?actual = ?expected as ?result
            ) 
        WHERE {}
    """ ;
    .

:deepEquals4
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:order 1 ;
        sh:path :expected ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 2 ;
        sh:path :actual ;
        sh:optional false ;
    ] ;
    sh:select """
        SELECT (true as ?result)
        WHERE {
            # if ?expected is a bnode structure, do deep compare
            ?expected ?p ?o .
            FILTER(ISBLANK(?expected))
            OPTIONAL {
                ?o ?p2 ?o2 .
                FILTER(ISBLANK(?o))
                OPTIONAL {
                    ?o2 ?p3 ?o3 .
                    FILTER(ISBLANK(?o2))
                    OPTIONAL {
                        ?o3 ?p4 ?o4 .
                        FILTER(!ISBLANK(?o4))
                    }
                }
            }
            FILTER EXISTS {
                {
                    ?actual ?p ?o 
                    FILTER(!ISBLANK(?o))
                } UNION {
                    ?actual ?p [ 
                        ?p2 ?o2
                    ]
                    FILTER(!ISBLANK(?o2))
                } UNION {
                    ?actual ?p [ 
                        ?p2 [
                            ?p3 ?o3 
                        ]
                    ]
                    FILTER(!ISBLANK(?o3))
                } UNION {
                    ?actual ?p [ 
                        ?p2 [
                            ?p3 [
                                ?p4 ?o4
                            ]
                        ]
                    ]
                    FILTER(!ISBLANK(?o4))
                }
            }
        }
    """ ;
    .

# Effect of a current `move` action that has a 
#    `vf:resourceInventoriedAs` and NO
#    `vf:toResourceInventoriedAs` :
# 
# - It generates one new resource states for `resource`
# - It copies all old values but changes the location to the event's location
#
# Note: there are problems with finding a boundary for the query so it can recurse in the star-shaped 
#       environment of the resource, but it does not go to far. 


:FnNewNodeUri 
        a           sh:SPARQLFunction ;
        sh:parameter [
            sh:path :parResourceUri ;
            sh:optional false ;
            sh:nodeKind sh:IRI ;
            sh:order 1 ;
        ] ;
        sh:parameter [
            sh:path :parEventUri ;
            sh:optional false ;
            sh:nodeKind sh:IRI ;
            sh:order 2 ;
        ] ;
        sh:prefixes vf: ;
        sh:select """
            SELECT
            (IRI(CONCAT("urn:wonvf:",
                SHA256(CONCAT(STR(?parResourceUri), 
                " ", 
                STR(?parEventUri))))) 
                as ?result) 
            WHERE {}
        """;
        .

# Effect of a current `move` action that has a 
#    `vf:resourceInventoriedAs` and NO
#    `vf:toResourceInventoriedAs` :
# 
# - It generates one new resource states for `resource`
# - It copies all old values but changes the location to the event's location
# - Copying includes blank node structures connected to the resource, 
#   but not infinitely deep (see RuleCopyOtherBNodeStructuresToNextState)
:CurrentEventEffectsShape_move
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:move
        ] ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationFromEventToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

# Effect of a current `move` action that has a 
#    `vf:resourceInventoriedAs` and a
#    `vf:toResourceInventoriedAs` :
# 
# It generates new resource states for `resource` and `toResource`
#   - sets both `vf:onhandQuantity` based on the event `vf:resourceQuantity`
# 
:CurrentEventEffectsShape_move_toResource
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget_toResource ;
            :parAction vf:move
        ] ;
        sh:rule :RuleCopyOnhandQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState_toResource ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState_toResource ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleLinkFromNextState_toResource ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyLocationToNextState_toResource ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyPrimaryAccountableToNextState_toResource ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState_toResource ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState_toResource ;
        .



:ConstantResourcePropertyConstraint
    a sh:ConstraintComponent ;
    sh:parameter [
        sh:path :constantResourceProperty ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:nodeValidator [
        a sh:SPARQLSelectValidator ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this ?message
            WHERE {
                ?this vf:resourceInventoriedAs ?res .
                ?next vf:previousState ?res .
                ?res ?constantResourceProperty ?val .
                ?next ?constantResourceProperty ?nextVal .
                {
                    ?res ?constantResourceProperty ?val .
                    ?next ?constantResourceProperty ?nextVal .
                    FILTER(!ISBLANK(?val) && !ISBLANK(?nextVal) && ?val != ?nextVal)
                    BIND(
                        CONCAT(
                            "Event ",
                            STR(?this),
                            " is not allowed to change ",
                            STR(?constantResourceProperty),
                            ", but it changed from ",
                            IF(BOUND(?val),STR(?val),"[unbound]"),
                            " to ",
                            IF(BOUND(?nextVal),STR(?nextVal),"[unbound]"),
                            "."
                        ) 
                    as ?message)
                } UNION {
                    # if ?val is a bnode structure, do deep compare
                    ?res ?constantResourceProperty ?val .
                    ?next ?constantResourceProperty ?nextVal .
                    ?val ?p ?o .
                    FILTER(ISBLANK(?val))
                    OPTIONAL {
                        ?o ?p2 ?o2 .
                        FILTER(ISBLANK(?o))
                        OPTIONAL {
                           ?o2 ?p3 ?o3 .
                            FILTER(ISBLANK(?o2))
                            OPTIONAL {
                                ?o3 ?p4 ?o4 .
                                FILTER(ISBLANK(?o4))
                        }
                        }
                    }
                    FILTER NOT EXISTS {
                        {
                            ?next ?constantResourceProperty [ 
                                ?p ?o 
                            ]
                            FILTER(!ISBLANK(?o))
                        } UNION {
                            ?next ?constantResourceProperty [ 
                                ?p [
                                    ?p2 ?o2
                                ]
                            ]
                            FILTER(!ISBLANK(?o2))
                        } UNION {
                            ?next ?constantResourceProperty [ 
                                ?p [
                                    ?p2 [
                                        ?p3 ?o3
                                    ]
                                ]
                            ]
                            FILTER(!ISBLANK(?o3))
                        } UNION {
                            ?next ?constantResourceProperty [ 
                                ?p [
                                    ?p2 [
                                        ?p3 [
                                            ?p4 ?o4
                                        ]
                                    ]
                                ]
                            ]
                            FILTER(!ISBLANK(?o4))
                        }

                    }
                    BIND(
                        CONCAT(
                            "Event ",
                            STR(?this),
                            " is not allowed to change ",
                            STR(?constantResourceProperty),
                            ", but the structure of its bnode value has changed."
                        ) 
                    as ?message)
                }
            }
        """;
    ];
    .

:SameAsNextResourcePropertyConstraint
    a sh:ConstraintComponent ;
    sh:parameter [
        sh:path :sameAsNextResourceProperty ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:propertyValidator [
        a sh:SPARQLSelectValidator ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this ?message
            WHERE {
                {
                    ?this ?PATH ?eventVal .
                    ?this vf:resourceInventoriedAs ?res .
                    ?res ?sameAsNextResourceProperty ?val .
                    ?next vf:previousState ?res .
                    ?next ?sameAsNextResourceProperty ?nextVal .
                    FILTER(
                        (!ISBLANK(?val) && !ISBLANK(?nextVal) && !ISBLANK(?eventVal)) 
                        && 
                            (  ?val = ?nextVal 
                            || ?eventVal != ?nextVal)
                    )
                    BIND(
                        CONCAT(
                            "Event ",
                            STR(?this),
                            " must change the resource property ",
                            STR(?sameAsNextResourceProperty),
                            " to its value of property ",
                            IF(BOUND(?PATH), STR(?PATH),"[unbound]"),
                            ", which would be ",
                            IF(BOUND(?eventVal), STR(?eventVal),"[unbound]"),
                            " but the new value is ",
                            IF(BOUND(?nextVal), STR(?nextVal),"[unbound]"),
                            " ."
                        ) 
                    as ?message)
                } UNION {
                    # if ?val is a bnode structure, do deep compare
                    ?this ?PATH ?eventVal .
                    ?this vf:resourceInventoriedAs ?res .
                    ?res ?sameAsNextResourceProperty ?val .
                    ?next vf:previousState ?res .
                    ?next ?sameAsNextResourceProperty ?nextVal .
                    ?val ?p ?o .
                    FILTER(ISBLANK(?val))
                    OPTIONAL {
                        ?o ?p2 ?o2 .
                        FILTER(ISBLANK(?o))
                        OPTIONAL {
                           ?o2 ?p3 ?o3 .
                            FILTER(ISBLANK(?o2))
                            OPTIONAL {
                                ?o3 ?p4 ?o4 .
                                FILTER(ISBLANK(?o4))
                        }
                        }
                    }
                    FILTER NOT EXISTS {
                        {
                            ?next ?sameAsNextResourceProperty [ 
                                ?p ?o 
                            ]
                            FILTER(!ISBLANK(?o))
                        } UNION {
                            ?next ?sameAsNextResourceProperty [ 
                                ?p [
                                    ?p2 ?o2
                                ]
                            ]
                            FILTER(!ISBLANK(?o2))
                        } UNION {
                            ?next ?sameAsNextResourceProperty [ 
                                ?p [
                                    ?p2 [
                                        ?p3 ?o3
                                    ]
                                ]
                            ]
                            FILTER(!ISBLANK(?o3))
                        } UNION {
                            ?next ?sameAsNextResourceProperty [ 
                                ?p [
                                    ?p2 [
                                        ?p3 [
                                            ?p4 ?o4
                                        ]
                                    ]
                                ]
                            ]
                            FILTER(!ISBLANK(?o4))
                        }

                    }
                    BIND(
                        CONCAT(
                           "Event ",
                            STR(?this),
                            " must change the resource property ",
                            STR(?sameAsNextResourceProperty),
                            " to its value of property ",
                            IF(BOUND(?PATH), STR(?PATH),"[unbound]"),
                            " (which is a bnode structure) ",
                            IF(BOUND(?eventVal), STR(?eventVal),"[unbound]"),
                            " but the new value differs from that."
                        ) 
                    as ?message)
                }
            }
        """;
    ];
    .

:RequireLinkFromNextState 
    a sh:NodeShape ;
    sh:sparql [
        a sh:Sparql
    ]
    .


:RuleLinkFromNextState 
    a sh:TripleRule ;
    sh:subject [
        :FnNewNodeUri (
            [ sh:path vf:resourceInventoriedAs ]
            sh:this 
        )
    ] ;
    sh:predicate vf:previousState ;
    sh:object [
        sh:path vf:resourceInventoriedAs ;
    ] ;
    .

:RuleLinkFromNextState_toResource
    a sh:TripleRule ;
    sh:subject [
        :FnNewNodeUri (
            [ sh:path vf:toResourceInventoriedAs ]
            sh:this 
        )
    ] ;
    sh:predicate vf:previousState ;
    sh:object [
        sh:path vf:toResourceInventoriedAs ;
    ] ;
    .

:RuleCopyLocationFromEventToNextState    
    sh:condition [
        sh:path vf:atLocation ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        :FnNewNodeUri ( 
            [ sh:path vf:resourceInventoriedAs ] 
            sh:this 
        ) ;
    ] ;
    sh:predicate vf:currentLocation ;
    sh:object [
        sh:path vf:atLocation ;
    ] ;
.

:RuleCopyLocationToNextState    
    sh:condition [
        sh:path ( vf:resourceInventoriedAs vf:currentLocation ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        :FnNewNodeUri ( 
            [ sh:path vf:resourceInventoriedAs ] 
            sh:this 
        ) ;
    ] ;
    sh:predicate vf:currentLocation ;
    sh:object [
        sh:path ( vf:resourceInventoriedAs vf:currentLocation );
    ] ;
.

:RuleCopyLocationToNextState_toResource   
    sh:condition [
        sh:path ( vf:toResourceInventoriedAs vf:currentLocation ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        :FnNewNodeUri ( 
            [ sh:path vf:toResourceInventoriedAs ] 
            sh:this 
        ) ;
    ] ;
    sh:predicate vf:currentLocation ;
    sh:object [
        sh:path ( vf:toResourceInventoriedAs vf:currentLocation );
    ] ;
.

:RuleCopyPrimaryAccountableToNextState    
    sh:condition [
        sh:path ( vf:resourceInventoriedAs vf:primaryAccountable ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        :FnNewNodeUri ( 
            [ sh:path vf:resourceInventoriedAs ] 
            sh:this 
        ) ;
    ] ;
    sh:predicate vf:primaryAccountable ;
    sh:object [
        sh:path ( vf:resourceInventoriedAs vf:primaryAccountable );
    ] ;
.

:RuleCopyPrimaryAccountableToNextState_toResource   
    sh:condition [
        sh:path ( vf:toResourceInventoriedAs vf:primaryAccountable ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        :FnNewNodeUri ( 
            [ sh:path vf:toResourceInventoriedAs ] 
            sh:this 
        ) ;
    ] ;
    sh:predicate vf:primaryAccountable ;
    sh:object [
        sh:path ( vf:toResourceInventoriedAs vf:primaryAccountable );
    ] ;
.

:RuleCopyOnhandQuantityToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res  vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
    .

:RuleCopyOnhandQuantityDecreasedByEventQuantityToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?newValueLiteral
                ] 
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res  vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?eventValue 
                ] .
                BIND (?value - ?eventValue as ?newValue )
                BIND (DATATYPE(?value) as ?valueDatatype)
                BIND (DATATYPE(?eventValue) as ?eventValueDatatype)
                BIND (IF(BOUND(?valueDatatype),
                        ?valueDatatype, 
                        ?eventValueDatatype) 
                    as ?newValueDatatype)
                BIND (IF(BOUND(?newValueDatatype), 
                        STRDT(STR(?newValue), ?newValueDatatype),
                        ?newValue) 
                    as ?newValueLiteral)
            }""" ;
    .

:RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?newValueLiteral
                ] 
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?eventValue 
                ]
                BIND (?value + ?eventValue as ?newValue )
                BIND (DATATYPE(?value) as ?valueDatatype)
                BIND (DATATYPE(?eventValue) as ?eventValueDatatype)
                BIND (IF(BOUND(?valueDatatype),
                        ?valueDatatype, 
                        ?eventValueDatatype) 
                    as ?newValueDatatype)
                BIND (IF(BOUND(?newValueDatatype), 
                        STRDT(STR(?newValue), ?newValueDatatype),
                        ?newValue) 
                    as ?newValueLiteral)
            }""" ;
    .

:RuleCopyOnhandQuantityToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res  vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
    .


:RuleCopyAccountingQuantityToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res  vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
    .

:RuleCopyAccountingQuantityToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res  vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
    .

:RuleCopyOtherPropertiesToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?p ?o
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res  ?p ?o .
                FILTER(!ISBLANK(?o) 
                    && ! ( ?p IN (
                            rdf:type,
                            vf:previousState,
                            vf:currentLocation,
                            vf:onhandQuantity,
                            vf:accountingQuantity,
                            vf:primaryAccountable
                            )
                        )
                )
            }""" ;
    .

:RuleCopyOtherPropertiesToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?p ?o
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res  ?p ?o .
                FILTER(!ISBLANK(?o) 
                    && ! ( ?p IN (
                            rdf:type,
                            vf:previousState,
                            vf:currentLocation,
                            vf:onhandQuantity,
                            vf:accountingQuantity,
                            vf:primaryAccountable
                            )
                        )
                )
            }""" ;
    .    

:RuleCopyOtherBNodeStructuresToNextState 
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?p ?o .
                ?o ?p2 ?o2 .
                ?o2 ?p3 ?o3 .
                ?o3 ?p4 ?o4 .
                ?o4 ?p5 ?o5 .
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res  ?p ?o .
                ?o ?p2 ?o2 . # not optional - what good would an unonnected BNODE be?
                FILTER(ISBLANK(?o) 
                    && ! ( ?p IN (
                            vf:onhandQuantity,
                            vf:accountingQuantity
                            # we do not filter vf:currentLocation in case it's a BNODE structure
                            )
                        )
                )
                OPTIONAL {
                    FILTER (ISBLANK(?o2))
                    ?o2 ?p3 ?o3 
                    OPTIONAL {
                        FILTER (ISBLANK(?o3))
                        ?o3 ?p4 ?o4 
                        OPTIONAL {
                            FILTER (ISBLANK(?o3))
                            ?o4 ?p5 ?o5 
                    }
                    }
                }
            
            }""" ;
    .

:RuleCopyOtherBNodeStructuresToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?p ?o .
                ?o ?p2 ?o2 .
                ?o2 ?p3 ?o3 .
                ?o3 ?p4 ?o4 .
                ?o4 ?p5 ?o5 .
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(vfs:FnNewNodeUri(?res, ?this) as ?next)
                ?res  ?p ?o .
                ?o ?p2 ?o2 . # not optional - what good would an unonnected BNODE be?
                FILTER(ISBLANK(?o) 
                    && ! ( ?p IN (
                            vf:onhandQuantity,
                            vf:accountingQuantity
                            # we do not filter vf:currentLocation in case it's a BNODE structure
                            )
                        )
                )
                OPTIONAL {
                    FILTER (ISBLANK(?o2))
                    ?o2 ?p3 ?o3 
                    OPTIONAL {
                        FILTER (ISBLANK(?o3))
                        ?o3 ?p4 ?o4 
                        OPTIONAL {
                            FILTER (ISBLANK(?o3))
                            ?o4 ?p5 ?o5 
                    }
                    }
                }
            
            }""" ;
    .

## `vf:move` connected to two resources


# Invariants specific for move actions with `vf:resourceInventoriedAs` and `vf:toResourceInventoriedAs`:
# - The two resources must have different `vf:currentLocation` values
# - The toResource must have the same `vf:currentLocation` as the event's `vf:atLocation`
# - The two resources must have identical `vf:onhandQuantity/om2:hasUnit` values
# - The two resources must have the same `vf:primaryAccountable`
# - The action's `vf:resourceQuantity/vf:om2:hasNumericalValue` must be larger than 
#   the resource's `vf:onhandQuantity`
# - The successor resources must not differ from their predecessors except in quantity as
#   results from the event quantity
:MoveEventShape_toResource
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_toResource ;
            :parAction vf:move
        ] ;
        sh:node :RequireLocationChangeShape_toResource ;
        sh:node :RequireCompatibleQuantitiesShape_toResource ; 
        sh:node :RequireSamePrimaryAccountableShape_toResource ;        
        sh:node :RequireSufficientQuantityForResourceDecrementShape ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:select """
            SELECT ?this (?quantityMessage as ?message)
            WHERE {
                ?this vf:resourceInventoriedAs ?res ;
                      vf:toResourceInventoriedAs ?toRes .
                ?succ   vf:previousState ?res .
                ?toSucc vf:previousState ?toRes .
                OPTIONAL {
                    # if this result is empty, the quantities are off or missing
                    ?res vf:onhandQuantity [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?resVal ;
                    ] .
                    ?toRes vf:onhandQuantity [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?toResVal ;
                    ] .
                    ?succ vf:onhandQuantity [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?succVal ;
                    ] .
                    ?toSucc vf:onhandQuantity [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?toSuccVal ; 
                    ] .
                    ?this vf:resourceQuantity [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?evVal ;
                    ]
                }     
                BIND(BOUND(?succVal) as ?qFound)
                BIND( (?succVal = ?resVal - ?evVal ) 
                    && ( ?toSuccVal = ?toResVal + ?evVal ) as ?qOk)
                FILTER( ! ?qFound || ! ?qOk)
                BIND(IF(?qFound,
                            IF( ?qOk, "quantities ok", "quantities do not add up"),
                            "quantities missing or wrong units") 
                    as ?quantityMessage )
            }
            """
            ]
        .

