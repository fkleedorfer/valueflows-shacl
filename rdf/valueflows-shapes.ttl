@prefix dfc:   <http://www.virtual-assembly.org/DataFoodConsortium/BusinessOntology#> .
@prefix owl:   <http://www.w3.org/2002/07/owl#> .
@prefix org:   <http://www.w3.org/ns/org#> .
@prefix xsd:   <http://www.w3.org/2001/XMLSchema#> .
@prefix dtype: <http://www.linkedmodel.org/schema/dtype#> .
@prefix skos:  <http://www.w3.org/2004/02/skos/core#> .
@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .
@prefix geo:   <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix vf:    <https://w3id.org/valueflows#> .
@prefix sh:    <http://www.w3.org/ns/shacl#> .
@prefix om2:   <http://www.ontology-of-units-of-measure.org/resource/om-2/> .
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix time:  <http://www.w3.org/2006/time#> .
@prefix vs:    <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .
@prefix om2: <http://www.ontology-of-units-of-measure.org/resource/om-2/> .
@prefix : <https://w3id.org/valueflows-shacl/shapes#> .
@prefix vfs: <https://w3id.org/valueflows-shacl/shapes#> .
@prefix ex: <http://example.org/ns#> .
@prefix fn: <https://w3id.org/shacl-commons/functions#> .


# Note: more info on validation rules:
#
# https://github.com/valueflows/vf-apps/issues/5
#   


vf: 
    sh:declare [
        sh:prefix "om2" ;
        sh:namespace "http://www.ontology-of-units-of-measure.org/resource/om-2/" ;
    ] ;
    sh:declare [
        sh:prefix "vf" ;
        sh:namespace "https://w3id.org/valueflows#" ;
    ] ;
    sh:declare [
        sh:prefix "vfs" ;
        sh:namespace "https://w3id.org/valueflows-shacl/shapes#" ;
    ] ;
    sh:declare [
        sh:prefix "fn" ;
        sh:namespace "https://w3id.org/shacl-commons/functions#" ;
    ] ;
    sh:declare [
        sh:prefix "owl" ;
        sh:namespace "http://www.w3.org/2002/07/owl#" ;
    ] ;
    sh:declare [
        sh:prefix "rdf" ;
        sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ;
    ] ;
    sh:declare [
        sh:prefix "xsd" ;
        sh:namespace "http://www.w3.org/2001/XMLSchema#" ;
    ] ;    
    .


:EconomicEventShape
        a               sh:NodeShape ;
        sh:targetClass vf:EconomicEvent ;
        sh:property :RequireProviderShape ;
        sh:property :RequireReceiverShape ;
        sh:property :ActionShape ;
        sh:property :ResourceInventoriedAsShape ;
        sh:property :ToResourceInventoriedAsShape ;
        sh:property :ResourceQuantityShape ;
        sh:property :ResourceClassifiedAsShape ;
        
        .

:EconomicResourceShape
        a               sh:NodeShape ;
        sh:targetClass  vf:EconomicResource ;
        sh:property     :AccountingQuantityShape ;
        sh:property     :OnhandQuantityShape ;
        sh:property     :ClassifiedAsShape ;
        sh:property     :TrackingIdentifierShape ;
        sh:property     :ConformsToShape ;
        sh:property     :ContainedInShape ;
        sh:property     :CurrentLocationShape ;
        sh:property     :PrimaryAccountableShape ;
# ignoring for now:         
#       sh:property     :lotShape ; unclear: what is product batch?
#       sh:property     :stageShape ;
#       sh:property     :stateShape ;
#       sh:property     :TrackingIdentifierShape ;
    .
:PrimaryAccountableShape
        a               sh:PropertyShape ;
        sh:path         vf:primaryAccountable ;
        sh:class        foaf:Agent ;
        sh:maxCount     1 ;
        .


:CurrentLocationShape
        a               sh:PropertyShape ;
        sh:path         vf:currentLocation ;
        sh:maxCount     1 ;
        .

:ConformsToShape 
        a               sh:PropertyShape ;
        sh:path         vf:conformsTo ;
        sh:class        vf:ResourceSpecification ;
        .

:ContainedInShape
        a               sh:PropertyShape ;
        sh:path         vf:containedIn ;
        sh:class        vf:EconomicResource ;
        .

:TrackingIdentifierShape
        a               sh:PropertyShape ;
        sh:path         vf:trackingIdentifier ;
        sh:nodeKind     sh:IRIOrLiteral ;
        sh:maxCount     1 ;
        .

:ResourceClassifiedAsShape
        a               sh:PropertyShape ;
        sh:path         vf:resourceClassifiedAs ;
        sh:nodeKind     sh:IRI ;        
        sh:maxCount     1 ;
        .

:ClassifiedAsShape
        a               sh:PropertyShape ;
        sh:path         vf:classifiedAs ;
        sh:nodeKind     sh:IRI ;        
        sh:maxCount     1 ;        
        .

:AccountingQuantityShape 
        a               sh:PropertyShape ;
        sh:path         vf:accountingQuantity ; 
        sh:node         :QuantityNodeShape ;
        sh:maxCount     1 ;
        sh:nodeKind     sh:BlankNodeOrIRI ;
        .

:QuantityNodeShape
        a               sh:NodeShape ;
        sh:property [
            sh:path om2:hasUnit ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path om2:hasNumericalValue ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:nodeKind sh:Literal ;
            sh:or (
                [ sh:datatype xsd:int ]
                [ sh:datatype xsd:integer ]
                [ sh:datatype xsd:double ]
                [ sh:datatype xsd:float ]
                [ sh:datatype xsd:decimal ]
                [ sh:datatype xsd:long ]
                [ sh:datatype xsd:short ]
            )
        ]
        .

:OnhandQuantityShape 
        a               sh:PropertyShape ;
        sh:node         :QuantityNodeShape ;
        sh:path         vf:onhandQuantity ;
        sh:maxCount     1 ;
        sh:nodeKind     sh:BlankNodeOrIRI ;         
        .

:ResourceQuantityShape
        a               sh:PropertyShape ;
        sh:node         :QuantityNodeShape ;
        sh:path         vf:resourceQuantity ;
        .

:ResourceInventoriedAsShape
        a               sh:PropertyShape ;
        sh:class        vf:EconomicResource ;
        sh:path         vf:resourceInventoriedAs ;
        sh:maxCount     1 ;
        .

:ToResourceInventoriedAsShape
        a               sh:PropertyShape ;
        sh:class        vf:EconomicResource ;
        sh:path         vf:toResourceInventoriedAs ;
        sh:maxCount     1 ;
        .


:RequireProviderShape
        a               sh:PropertyShape ;
        sh:path         vf:provider;
        sh:class        foaf:Agent ;
        sh:maxCount     1 ;
        sh:minCount     1 ;
        sh:nodeKind     sh:IRI ;
        .

:RequireReceiverShape
        a               sh:PropertyShape ;
        sh:path         vf:provider;
        sh:class        foaf:Agent ;
        sh:maxCount     1 ;
        sh:minCount     1 ;
        sh:nodeKind     sh:IRI ;
        .

:ActionShape
        a               sh:PropertyShape ;
        sh:path         vf:action ;
        sh:class        vf:Action ;
        sh:maxCount     1 ;
        sh:minCount     1 ;
        .      

###############################################################################
#   Domain-independent helper functions
###############################################################################

fn:getTypedLiteralForOp2
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:order 1 ;
        sh:path :in1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 2 ;
        sh:path :in2 ;
        sh:optional false ;
    ];
    sh:parameter [
        sh:order 3 ;
        sh:path :out ;
        sh:optional false ;
    ] ;
    sh:select """
        SELECT ?outLiteral 
        WHERE {
            BIND (DATATYPE(?in1) as ?in1Datatype)
            BIND (DATATYPE(?in2) as ?in2Datatype)
            BIND (IF(BOUND(?in1Datatype),
                    ?in1Datatype, 
                    ?in2Datatype) 
                as ?outDatatype)
            BIND (IF(BOUND(?outDatatype), 
                    STRDT(STR(?out), ?outDatatype),
                    ?out) 
                as ?outLiteral)
        }
    """ ;
    .


# Concatenates the parameters into a one string, separated by one whitespace
# Max number of params: 10
fn:stringConcatWithSpace
    a sh:SPARQLFunction ;
    sh:returnType xsd:string ;
    sh:parameter [
        sh:order 1 ;
        sh:path :arg1 ;
        sh:optional false;
    ];
    sh:parameter [
        sh:order 2 ;
        sh:path :arg2 ;
        sh:optional true ;
    ];
    sh:parameter [
        sh:order 3 ;
        sh:path :arg3 ;
        sh:optional true ;
    ];
    sh:parameter [
        sh:order 4 ;
        sh:path :arg4 ;
        sh:optional true ;
    ];
    sh:parameter [
        sh:order 5 ;
        sh:path :arg5 ;
        sh:optional true ;
    ];
    sh:parameter [
        sh:order 6 ;
        sh:path :arg6 ;
        sh:optional true ;
    ];
    sh:parameter [
        sh:order 7 ;
        sh:path :arg7 ;
        sh:optional true ;
    ];
    sh:parameter [
        sh:order 8 ;
        sh:path :arg8 ;
        sh:optional true ;
    ];
    sh:parameter [
        sh:order 9 ;
        sh:path :arg9 ;
        sh:optional true ;
    ];
    sh:parameter [
        sh:order 10 ;
        sh:path :arg10 ;
        sh:optional true ;
    ];
    sh:select """
        SELECT (GROUP_CONCAT(?elements; SEPARATOR=" ") as ?result) 
        WHERE {
            {
                BIND("all" as ?group)
                BIND(?arg1 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg2 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg3 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg4 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg5 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg6 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg7 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg8 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg9 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg10 as ?elements)
                FILTER(BOUND(?elements))
            }
        } GROUP BY (?group)
    """ ;
    .


fn:notBound
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :node ;
        sh:optional false ;
    ] ;
    sh:select """
    SELECT (!BOUND(?node) as ?result) 
    WHERE {}
    """ ;
    .

fn:bound 
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :node ;
        sh:optional false ;
    ] ;
    sh:select """
    SELECT (BOUND(?node) as ?result) 
    WHERE {}
    """ ;
    .

fn:onlyOneBound
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional true ;
    ] ;
    sh:select """
        SELECT ( 
            (BOUND(?op1) && !BOUND(?op2)) 
            || (!BOUND(?op1) && BOUND(?op2)) as ?result) 
        WHERE {}
    """;
    .
fn:allBound2
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional true ;
    ] ;
    sh:select """
        SELECT (  
                ( BOUND(?op1) && BOUND(?op2) )
            as ?result)
        WHERE {}
    """;
    .

fn:allBound3
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op3 ;
        sh:optional true ;
    ] ;
    sh:select """
        SELECT 
            ( 
                ( BOUND(?op1) && BOUND(?op2) && BOUND(?op3) )
            as ?result)
        WHERE {}
    """;
    .

fn:allBound4
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op4 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op3 ;
        sh:optional true ;
    ] ;
    sh:select """
        SELECT  
            (
                ( BOUND(?op1) && BOUND(?op2) && BOUND(?op3) && BOUND(?op4) )
            as ?result )
        WHERE {}
    """;
    .

fn:greaterThan
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
        sh:nodeKind sh:Literal ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional false ;
        sh:nodeKind sh:Literal ;
    ] ;
    sh:select """
        SELECT ( $op1 > $op2 as ?result )
        WHERE {}
    """;
    .


fn:greaterThanOrEquals
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
        sh:nodeKind sh:Literal ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional false ;
        sh:nodeKind sh:Literal ;
    ] ;
    sh:select """
        SELECT ( $op1 >= $op2 as ?result )
        WHERE {}
    """;
    .    

fn:equals
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional false ;
    ] ;
    sh:select """
        SELECT ( $op1 = $op2 as ?result )
        WHERE {}
    """;
    .    

fn:or 
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op3 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op4 ;
        sh:optional true ;
    ] ;
    sh:select """
    SELECT ( ?op1 || ?op2 || ?op3 || ?op4 as ?result) 
    WHERE {}
    """;
    .

fn:and 
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :op2 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op3 ;
        sh:optional true ;
    ] ;
    sh:parameter [
        sh:path :op4 ;
        sh:optional true ;
    ] ;
    sh:select """
    SELECT ( (!BOUND(?op1) || ?op1) 
          && (!BOUND(?op2) || ?op2)
          && (!BOUND(?op3) || ?op3) 
          && (!BOUND(?op4) || ?op4) as ?result) 
    WHERE {}
    """;
    .

fn:not 
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :op1 ;
        sh:optional false ;
    ] ;
    sh:select """
    SELECT ( ! ?op1 as ?result) 
    WHERE {}
    """;
    .

fn:pathEquals
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:order 1 ;
        sh:path :node1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 2 ;
        sh:path :path1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 3 ;
        sh:path :node2 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 4 ;
        sh:path :path2 ;
        sh:optional false ;
    ] ;
    sh:prefixes vf:;
    sh:select """
        SELECT ?result
        WHERE {
            ?node1 ?path1 ?value1 .
            ?node2 ?path2 ?value2 .
            BIND(
                IF(ISBLANK(?value1),
                fn:deepPathEquals4(?node1, ?path1, ?node2, ?path2),
                fn:IRIOrLiteralEquals(?value1,?value2)
            )
            as ?result
            )
        }
    """ ;
    .

fn:pathEqualsOrBothEmpty
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:order 1 ;
        sh:path :node1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 2 ;
        sh:path :path1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 3 ;
        sh:path :node2 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 4 ;
        sh:path :path2 ;
        sh:optional false ;
    ] ;
    sh:prefixes vf:;
    sh:select """
        SELECT ?result
        WHERE {
            OPTIONAL {
                ?node1 ?path1 ?value1 .
                ?node2 ?path2 ?value2 .
            }
            BIND(
                ( !BOUND(?value1) && !BOUND(?value2) )
                ||
                IF (
                    ISBLANK(?value1),
                    fn:deepPathEquals4(?node1, ?path1, ?node2, ?path2),
                    fn:IRIOrLiteralEquals(?value1,?value2)
                )
            as ?result
            )
        }
    """ ;
    .


fn:IRIOrLiteralEquals
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:order 1 ;
        sh:path :expected ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 2 ;
        sh:path :actual ;
        sh:optional false ;
    ] ;
    sh:select """
        SELECT (
                !ISBLANK(?actual) 
                && !ISBLANK(?expected) 
                && ?actual = ?expected as ?result
            ) 
        WHERE {}
    """ ;
    .

fn:deepPathEquals4
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:order 1 ;
        sh:path :node1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 2 ;
        sh:path :path1 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 3 ;
        sh:path :node2 ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:order 4 ;
        sh:path :path2 ;
        sh:optional false ;
    ] ;
    sh:select """
         # TODO: only detects that triples are missing, not when triples were added
         SELECT (COUNT(*) = 0 as ?result)
         WHERE {
            {
                ?node1 ?path1 ?expected .
                ?node2 ?path2 ?actual .
                ?expected ?p ?o .
                OPTIONAL {
                    ?o ?p2 ?o2 
                    FILTER (ISBLANK(?o))
                    OPTIONAL {
                        ?o2 ?p3 ?o3 
                        FILTER (ISBLANK(?o2))
                        OPTIONAL {
                            ?o3 ?p4 ?o4
                            FILTER (ISBLANK(?o3))
                        }
                    }
                }
                FILTER NOT EXISTS {
                    {
                        ?actual ?p ?o
                        FILTER(!ISBLANK(?o))
                    } UNION {
                        ?actual ?p [
                            ?p2 ?o2 
                        ]
                        FILTER(!ISBLANK(?o2)) 
                    } UNION {
                        ?actual ?p [
                            ?p2 [
                                ?p3 ?o3
                            ]
                        ]
                        FILTER(!ISBLANK(?o3)) 
                    } UNION {
                        ?actual ?p [
                            ?p2 [
                                ?p3 [
                                    ?p4 ?o4
                                ]
                            ]
                        ]
                        FILTER(!ISBLANK(?o4)) 
                    } 
                } 
            } UNION {
                ?node1 ?path1 ?expected .
                ?node2 ?path2 ?actual .
                ?actual ?p ?o .
                OPTIONAL {
                    ?o ?p2 ?o2 
                    FILTER (ISBLANK(?o))
                    OPTIONAL {
                        ?o2 ?p3 ?o3 
                        FILTER (ISBLANK(?o2))
                        OPTIONAL {
                            ?o3 ?p4 ?o4
                            FILTER (ISBLANK(?o3))
                        }
                    }
                }
                FILTER NOT EXISTS {
                    {
                        ?expected ?p ?o
                        FILTER(!ISBLANK(?o))
                    } UNION {
                        ?expected ?p [
                            ?p2 ?o2 
                        ]
                        FILTER(!ISBLANK(?o2)) 
                    } UNION {
                        ?expected ?p [
                            ?p2 [
                                ?p3 ?o3
                            ]
                        ]
                        FILTER(!ISBLANK(?o3)) 
                    } UNION {
                        ?expected ?p [
                            ?p2 [
                                ?p3 [
                                    ?p4 ?o4
                                ]
                            ]
                        ]
                        FILTER(!ISBLANK(?o4)) 
                    } 
                }
            }
        }
    """ ;
    .
 



fn:safeStr
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path fn:arg1 ;
        sh:optional false ;
        sh:order 1 ;
    ] ;
    sh:parameter [
        sh:path fn:name ;
        sh:optional true ;
        sh:datatype xsd:string ;
        sh:nodeKind sh:Literal ;
        sh:order 2 ;
    ] ;

    sh:select """
        SELECT ( 
            IF( 
                BOUND(?name),
                IF (
                    BOUND(?arg1),
                    STR(?arg1),
                    CONCAT("{?",?name,":unbound}")
                ),
                IF (
                    BOUND(?arg1),
                    STR(?arg1),
                    "{unbound}"
                )
            )
            as ?result
        )
        WHERE {}
    """ .
###############################################################################
#   Domain-specific helper functions
###############################################################################

fn:newNodeURI 
        a           sh:SPARQLFunction ;
        sh:parameter [
            sh:path :parEventUri ;
            sh:optional false ;
            sh:nodeKind sh:IRI ;
            sh:order 1 ;
        ] ;        
        sh:parameter [
            rdfs:comment "This parameter is optional as in the case of a 'create' event there is no resource to use for generating the next state's URI" ;
            sh:path :parResourceUri ;
            sh:optional true ;
            sh:nodeKind sh:IRI ;
            sh:order 2 ;
        ] ;
        sh:prefixes vf: ;
        sh:select """
            SELECT
                (
                    IRI(
                        CONCAT(
                            "urn:wonvf:",
                            SHA256(
                                CONCAT(
                                    IF (
                                        BOUND(?parResourceUri) && ISIRI(?parResourceUri),
                                        STR(?parResourceUri),
                                        "[no-resource]"  
                                    ), 
                                    " ", 
                                    STR(?parEventUri)
                                )
                            )
                        )
                    )    
                    as ?result
                ) 
            WHERE {}
        """;
        .

:affectsNoResourcePropertiesExcept
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :parEvent ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
        sh:order 1 ;
    ] ;
    sh:parameter [
        sh:path :parAffectedList ;
        sh:nodeKind xsd:string ;
        sh:optional true ;
        sh:order 2 ;
    ] ;
    sh:prefixes vf: ;
    sh:select """
        SELECT ( 
            vfs:_affectsNoResourcePropertiesExcept(
                ?parEvent, 
                vf:resourceInventoriedAs,
                ?parAffectedList) 
            as ?result
        )
        WHERE {}
    """;
    .

:affectsNoResourcePropertiesExcept_toResource
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :parEvent ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
        sh:order 1 ;
    ] ;
    sh:parameter [
        sh:path :parAffectedList ;
        sh:nodeKind xsd:string ;
        sh:optional true ;
        sh:order 2 ;
    ] ;
    sh:prefixes vf: ;
    sh:select """
        SELECT ( 
            vfs:_affectsNoResourcePropertiesExcept(
                ?parEvent, 
                vf:toResourceInventoriedAs, 
                ?parAffectedList) 
            as ?result
        )
        WHERE {}
    """;
    .

:_affectsNoResourcePropertiesExcept
    a sh:SPARQLFunction ;
    sh:parameter [
        sh:path :parEvent ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
        sh:order 1 ;
    ] ;
    sh:parameter [
        sh:path :parConnectingProp;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
        sh:order 2 ;
    ] ;
    sh:parameter [
        sh:path :parAffectedList ;
        sh:nodeKind xsd:string ;
        sh:optional true ;
        sh:order 3 ;
    ] ;
    sh:prefixes vf: ;
    sh:select """
        SELECT (COUNT(*) = 0 as ?result)
        WHERE {
            # required structure (or test will pass silently):
            # event-resource-property
            ?parEvent ?parConnectingProp ?res .
            ?next vf:previousState ?res .
            
            # do not compare properties from the list
            FILTER(!CONTAINS(?parAffectedList, STR(?resProp)))

            # does the resource have the property?
            OPTIONAL {
                ?res ?resProp ?val .
            }

            # does the next state have the property?
            OPTIONAL {
                ?next ?resProp ?nextVal .
            }

            # produce result 
            # - if values aren't equal
            # - if only one is bound (property appeared or disappeared)
            FILTER(
                fn:onlyOneBound(?val, ?nextVal)
                || 
                ! fn:pathEquals(
                    ?res, ?resProp, 
                    ?next, ?resProp
                  )
            )
        }
    """;
    .


###############################################################################
#      Target Functions for selecting focus nodes
###############################################################################

# SPARQLTarget shape for selecting 
#   - all events 
#   - by action
#   - that do not have a toResourceIA
:EventsTarget_noToResource
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:action                   ?parAction ;
                    vf:resourceInventoriedAs    [] ;
                .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriedAs  []               
                }
 			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - all events 
#   - by action
#   - that have 
#      * neither a `vf:resourceInventoriedAs` 
#      * nor a `vf:toResourceInventoriedAs` 
:EventsTarget_noResource
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a           vf:EconomicEvent ;
                    vf:action   ?parAction ;        
                .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriedAs  []               
                }
                FILTER NOT EXISTS {
                    ?this vf:ResourceInventoriedAs  []               
                }

 			}
			""" ;
        .


# SPARQLTarget shape for selecting 
#   - current events 
#   - by action
#   - that do not have a toResourceIA
:CurrentEventsTarget
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    ?res ;
                    vf:action                   ?parAction ;
                    .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriedAs []
                }
                FILTER NOT EXISTS {
                    [] vf:previousState ?res 
                } 
			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - all events 
#   - by action
#   - that have a toResourceIA
:EventsTarget_toResource
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
            sh:optional false ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    [] ;
                    vf:toResourceInventoriedAs  [] ;
                    vf:action                   ?parAction ;
                    .
 			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - current events 
#   - by action
#   - that have a toResourceIA
:CurrentEventsTarget_toResource
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
            sh:optional false ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    ?res ;
                    vf:toResourceInventoriedAs  ?toRes ;
                    vf:action                   ?parAction ;
                    .
                FILTER NOT EXISTS {
                    [] vf:previousState ?toRes 
                }
                FILTER NOT EXISTS {
                    [] vf:previousState ?res 
                } 
			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - by action
#   - that have 
#      * neither a `vf:resourceInventoriedAs` 
#      * nor a `vf:toResourceInventoriedAs` 
# ...By definition, these events are current: the only ones allowed in this
# shape are events that CREATE a resource. The created resource can be 
# inferred. As soon as these triples are added to the DB, the event is no longer
# current.
:CurrentCreateEventsTarget
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:action                   ?parAction ;
                    .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriedAs  []               
                }
                FILTER NOT EXISTS {
                    ?this vf:ResourceInventoriedAs  []               
                }
			}
			""" ;
        .

###############################################################################
#    Invariant-checking constraints
###############################################################################

:EconomicEventHasTwoEconomicResourcesShape
    a           sh:NodeShape ;
    sh:class    vf:EconomicEvent ;
    sh:property [
        sh:path     vf:resourceInventoriedAs ;
        sh:class    vf:EconomicResource ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    sh:property [
        sh:path     vf:toResourceInventoriedAs ;
        sh:class    vf:EconomicResource ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    .

:UnaffectedResourcePropertyConstraint
    a sh:ConstraintComponent ;
    sh:parameter [
        sh:path :unaffectedResourceProperty ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:nodeValidator [
        a sh:SPARQLSelectValidator ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this ?message 
            WHERE {
                ?this vf:resourceInventoriedAs ?res .
                ?next vf:previousState ?res .
                OPTIONAL {
                    ?next ?unaffectedResourceProperty ?nextVal .
                }
                OPTIONAL {
                    ?res ?unaffectedResourceProperty ?val .
                } 
                FILTER(
                       # error if values aren't equal
                       ! fn:pathEquals(
                           ?res, ?unaffectedResourceProperty, 
                           ?next, ?unaffectedResourceProperty)
                    || # error if only one property of the two is present
                        fn:onlyOneBound(?val, ?nextVal) 
                )
                BIND(IF(
                        BOUND(?val) && BOUND(?nextVal),
                        IF(
                            ISBLANK(?val),
                            CONCAT(
                                "Event ",
                                STR(?this),
                                " is not allowed to change ",
                                STR(?unaffectedResourceProperty),
                                ", but the structure of its bnode value has changed."
                            ) ,
                            CONCAT(
                                "Event ",
                                STR(?this),
                                " is not allowed to change ",
                                STR(?unaffectedResourceProperty),
                                ", but it changed from ",
                                fn:safeStr(?val,"val"),
                                " to ",
                                fn:safeStr(?nextVal,"nextVal"),
                                "."
                            ) 
                        ),
                        CONCAT(
                                "Event ",
                                STR(?this),
                                " is not allowed to affect ",
                                STR(?unaffectedResourceProperty),
                                " of the resource, but it is only present in one of its states."
                        )
                    ) 
                    as ?message
                )
            }
        """;
    ];
    .


:UnaffectedResourcePropertyConstraint_toResource
    a sh:ConstraintComponent ;
    sh:parameter [
        sh:path :unaffectedResourceProperty_toResource ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:nodeValidator [
        a sh:SPARQLSelectValidator ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this ?message
            WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                ?next vf:previousState ?res .
                OPTIONAL {
                    ?next ?unaffectedResourceProperty_toResource ?nextVal .
                }
                OPTIONAL {
                    ?res ?unaffectedResourceProperty_toResource ?val .
                }
                FILTER(BOUND(?next))
                FILTER(
                    fn:onlyOneBound(?val, ?nextVal)
                    ||
                    ! fn:pathEquals(?res, ?unaffectedResourceProperty_toResource, ?next, ?unaffectedResourceProperty_toResource)
                )
                BIND(IF(BOUND(?val) && BOUND(?nextVal),
                        IF(
                            ISBLANK(?val),
                            CONCAT(
                                "Event ",
                                STR(?this),
                                " is not allowed to change ",
                                STR(?unaffectedResourceProperty_toResource),
                                " of its vf:toResourceInventoriedAs ",
                                ", but the structure of its bnode value has changed."
                            ) ,
                            CONCAT(
                                "Event ",
                                STR(?this),
                                " is not allowed to change ",
                                STR(?unaffectedResourceProperty_toResource),
                                " of its vf:toResourceInventoriedAs ",
                                ", but it changed from ",
                                fn:safeStr(?val,"val"),
                                " to ",
                                fn:safeStr(?nextVal,"nextVal"),
                                "."
                            ) 
                        ), 
                        CONCAT(
                            "Event ",
                            STR(?this),
                            " is not allowed to change ",
                            STR(?unaffectedResourceProperty_toResource),
                            " of its vf:toResourceInventoriedAs ",
                            ", but it is only present in one of its states."
                        ) 
                    )
                    as ?message
                )
            }
        """;
    ];
    .

:SameAsResourcePropertyConstraint
    a sh:ConstraintComponent ;
    sh:parameter [
        sh:path :sameAsResourceProperty ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :resourcePath ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:propertyValidator [
        a sh:SPARQLSelectValidator ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this ?message
            WHERE {
                ?this ?PATH ?eventVal .
                OPTIONAL {
                    ?this ?resourcePath ?res .
                    ?res ?sameAsResourceProperty ?val .
                }
                FILTER(
                    fn:onlyOneBound(?val, ?eventVal)
                    || ! fn:pathEquals(?this, ?PATH, ?res, ?sameAsResourceProperty)
                )
                BIND(
                    IF(BOUND(?val) && BOUND(?eventVal),
                        IF(ISBLANK(?val),
                            CONCAT(
                            "Event ",
                                STR(?this),
                                ", / ",
                                fn:safeStr(?PATH,"PATH"),
                                " (which is a bnode structure) ",
                                " must be equal to its ",
                                STR(?resourcePath),
                                " resource ",
                                STR(?res),
                                ", / ",
                                STR(?sameAsResourceProperty),
                                " but the structures differ."
                            ),
                            CONCAT(
                                "Event ",
                                STR(?this),
                                ", / ",
                                fn:safeStr(?PATH,"PATH"),
                                " must be equal to its ",
                                STR(?resourcePath),
                                " resource ",
                                STR(?res),
                                ", / ",
                                STR(?sameAsResourceProperty),
                                " but the values are ",
                                fn:safeStr(?eventVal,"eventVal"),
                                " and ",
                                fn:safeStr(?val,"val")
                            )
                        ),
                        CONCAT(
                            "Event ",
                            STR(?this),
                            ", / ",
                            fn:safeStr(?PATH,"PATH"),
                            " must be equal to its ",
                            STR(?resourcePath),
                            " resource ",
                            STR(?res),
                            ", / ",
                            STR(?sameAsResourceProperty),
                            ", but only one of them is present."
                        )
                    )
                    as ?message
                )
            }
        """;
    ];
    .


:SameAsNextResourcePropertyConstraint
    a sh:ConstraintComponent ;
    sh:parameter [
        sh:path :sameAsNextResourceProperty ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :resourcePath ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:propertyValidator [
        a sh:SPARQLSelectValidator ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this ?message
            WHERE {
                ?this ?PATH ?eventVal .
                ?this ?resourcePath ?res .
                ?next vf:previousState ?res .
                OPTIONAL {
                    ?next ?sameAsNextResourceProperty ?nextVal .
                }
                FILTER(
                    fn:onlyOneBound(?eventVal, ?nextVal)
                    ||
                    ! fn:pathEquals(?this, ?PATH, ?next, ?sameAsNextResourceProperty)
                )
                BIND(
                    IF(BOUND(?eventVal) && BOUND(?nextVal),
                        IF(ISBLANK(?eventVal),
                            CONCAT(
                                "Event ",
                                STR(?this),
                                " must set its ",
                                STR(?resourcePath),
                                " resource ",
                                STR(?next),
                                " / ",
                                STR(?sameAsNextResourceProperty),
                                " to its value of property ",
                                fn:safeStr(?PATH,"PATH"),
                                " (which is a bnode structure) ",
                                " but the new value ",
                                fn:safeStr(?nextVal,"nextVal"),
                                " differs from that."
                            ),
                            CONCAT(
                                "Event ",
                                STR(?this),
                                " must set its ",
                                STR(?resourcePath),
                                " resource ",
                                STR(?next),
                                " / ",
                                STR(?sameAsNextResourceProperty),
                                " to its value of property ",
                                fn:safeStr(?PATH,"PATH"),
                                ", which would be ",
                                fn:safeStr(?eventVal,"eventVal"),
                                " but the new value is ",
                                fn:safeStr(?nextVal,"nextVal"),
                                " ."
                            )
                        ),
                        CONCAT(
                            "Event ",
                            STR(?this),
                            " must set its ",
                            STR(?resourcePath),
                            " resource ",
                            STR(?next),
                            " / ",
                            STR(?sameAsNextResourceProperty),
                            " to its value of property ",
                            fn:safeStr(?PATH,"PATH"),
                            ", but at least one of these two values is missing." 
                        )
                    )
                    as ?message
                )
            }
        """;
    ];
    .

:EventDecreasesResourcePropertyConstraint
    a sh:ConstraintComponent ;
    sh:parameter [
        sh:path :eventDecreasesResourceProperty ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :resourcePath ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;  
    sh:parameter [
        sh:path :allowResultBelowZero ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;      
    sh:propertyValidator [
        a sh:SPARQLSelectValidator ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this ?message
            WHERE {
                ?this ?resourcePath ?res .
                OPTIONAL {
                    ?this ?PATH [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?eventValue 
                    ] .
                }
                OPTIONAL {
                    ?res ?eventDecreasesResourceProperty [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?resValue
                    ] .  
                }
                OPTIONAL {
                    # we make ?next optional independently of the property
                    # so we can check for below-zero values
                    # even without the next state
                    ?next vf:previousState ?res .
                }
                OPTIONAL {
                    ?next vf:previousState ?res .
                    ?next ?eventDecreasesResourceProperty [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?nextValue
                    ] .  
                }
                BIND (
                    fn:getTypedLiteralForOp2(
                        ?resValue, 
                        ?eventValue, 
                        ?resValue - ?eventValue) 
                    as ?expectedNextValue
                )
                BIND ((fn:allBound2(?eventValue, ?resValue) 
                        && ( ! ?allowResultBelowZero )
                        && ( ?resValue - ?eventValue < 0)) as ?opForbidden)
                # allow to produce result(error) even without a next state
                FILTER (
                    ?opForbidden
                    ||
                    (
                        BOUND(?next)
                        &&
                        (
                            ! fn:allBound4(?eventValue, ?resValue, ?nextValue, ?expectedNextValue) 
                            || 
                            ( ?expectedNextValue != ?nextValue  )
                        )
                    )
                )
                BIND (IF(?opForbidden,
                        CONCAT(
                            "Event ", 
                            STR(?this),
                            " must decrease its resource ",
                            STR(?res),
                            " / ",
                            STR(?eventDecreasesResourceProperty),
                            " value by ", 
                            STR(?eventValue),
                            ", from ",
                            STR(?resValue),
                            " to ",
                            STR(?expectedNextValue),
                            ", but that change is forbidden."
                        ),
                        IF(
                            fn:allBound4(?eventValue, ?resValue, ?nextValue, ?expectedNextValue), 
                            CONCAT(
                                "Event ", 
                                STR(?this),
                                " must decrease its resource ",
                                STR(?res),
                                " / ",
                                STR(?eventDecreasesResourceProperty),
                                " value by ", 
                                STR(?eventValue),
                                ", from ",
                                STR(?resValue),
                                " to ",
                                STR(?expectedNextValue),
                                ", but the actual next value is ",
                                STR(?nextValue),
                                "."
                            ),
                            CONCAT(
                                "Event ", 
                                STR(?this), 
                                " must decrease its resource ",
                                STR(?res),
                                " / ",
                                STR(?eventDecreasesResourceProperty),
                                " value by ", 
                                STR(?eventValue), 
                                " but at least one of the properties is missing."
                            )
                        )
                    )
                    as ?message                    
                )
                 
            }
            """ ;
        ] ;
    .

:EventIncreasesResourcePropertyConstraint
    a sh:ConstraintComponent ;
    sh:parameter [
        sh:path :eventIncreasesResourceProperty ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:parameter [
        sh:path :resourcePath ;
        sh:nodeKind sh:IRI ;
        sh:optional false ;
    ] ;
    sh:propertyValidator [
        a sh:SPARQLSelectValidator ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this ?message
            WHERE {
                ?this ?resourcePath ?res .
                ?next vf:previousState ?res .   # no next state - no problem
                OPTIONAL {
                    ?this ?PATH [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?eventValue 
                    ] .
                }
                OPTIONAL {
                    ?res ?eventIncreasesResourceProperty [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?resValue
                    ] .  
                }
                OPTIONAL {
                    ?next ?eventIncreasesResourceProperty [
                        om2:hasUnit ?unit ;
                        om2:hasNumericalValue ?nextValue
                    ] .  
                }
                BIND (
                    fn:getTypedLiteralForOp2(
                        ?resValue, 
                        ?eventValue, 
                        ?resValue + ?eventValue) 
                    as ?expectedNextValue
                )
                FILTER (
                    ! fn:allBound4(?eventValue, ?resValue, ?nextValue, ?expectedNextValue) 
                    || 
                    ( ?expectedNextValue != ?nextValue  )
                )
                BIND (
                    IF(
                        fn:allBound4(?eventValue, ?resValue, ?nextValue, ?expectedNextValue), 
                        CONCAT(
                            "Event ", 
                            STR(?this),
                            " must increase its resource ",
                            STR(?res),
                            " / ",
                            STR(?eventIncreasesResourceProperty),
                            " value by ", 
                            STR(?eventValue),
                            ", from ",
                            STR(?resValue),
                            " to ",
                            STR(?expectedNextValue),
                            ", but the actual next value is ",
                            STR(?nextValue),
                            "."
                        ),
                        CONCAT(
                            "Event ", 
                            STR(?this), 
                            " must increase its resource ",
                            STR(?res),
                            " / ",
                            STR(?eventDecreasesResourceProperty),
                            " value by ", 
                            STR(?eventValue), 
                            " but one of the properties is missing."
                        )
                    )
                    as ?message                    
                )
                 
            }
            """ ;
        ] ;
    .

###############################################################################
#           Rules for copying data from the old state of an 
#           EconomicResource to its new state when an EconomicEvent happens.
###############################################################################


:RuleCreateInitialAndNextState
    a sh:SPARQLRule ;
    sh:prefixes vf: ;
    sh:construct """
        CONSTRUCT {
            ?this vf:resourceInventoriedAs  ?initial .
            ?next vf:previousState ?initial .
            ?initial a vf:EconomicResource .
        } WHERE {
            BIND(fn:newNodeURI(?this) as ?next)
            BIND(BNODE() as ?initial) 
         }
    """ ;
    .



:RuleLinkFromNextState 
    a sh:TripleRule ;
    sh:subject [
        fn:newNodeURI (
            sh:this 
            [ sh:path vf:resourceInventoriedAs ]
        )
    ] ;
    sh:predicate vf:previousState ;
    sh:object [
        sh:path vf:resourceInventoriedAs ;
    ] ;
    .






:RuleCreateNextState
    a sh:TripleRule ;
    sh:subject [
        fn:newNodeURI (
            sh:this 
            [ sh:path vf:resourceInventoriedAs ]
        )
    ] ;
    sh:predicate rdf:type ;
    sh:object vf:EconomicResource ;
    .



:RuleLinkFromNextState 
    a sh:TripleRule ;
    sh:subject [
        fn:newNodeURI (
            sh:this 
            [ sh:path vf:resourceInventoriedAs ]
        )
    ] ;
    sh:predicate vf:previousState ;
    sh:object [
        sh:path vf:resourceInventoriedAs ;
    ] ;
    .

:RuleCreateNextState_toResource
    a sh:TripleRule ;
    sh:subject [
        fn:newNodeURI (
            sh:this 
            [ sh:path vf:toResourceInventoriedAs ]
        )
    ] ;
    sh:predicate rdf:type ;
    sh:object vf:EconomicResource ;
    .

:RuleLinkFromNextState_toResource
    a sh:TripleRule ;
    sh:subject [
        fn:newNodeURI (
            sh:this 
            [ sh:path vf:toResourceInventoriedAs ]
        )
    ] ;
    sh:predicate vf:previousState ;
    sh:object [
        sh:path vf:toResourceInventoriedAs ;
    ] ;
    .

:RuleCopyLocationFromEventToNextState    
    sh:condition [
        sh:path vf:atLocation ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:resourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:currentLocation ;
    sh:object [
        sh:path vf:atLocation ;
    ] ;
.

:RuleCopyLocationToNextState    
    sh:condition [
        sh:path ( vf:resourceInventoriedAs vf:currentLocation ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:resourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:currentLocation ;
    sh:object [
        sh:path ( vf:resourceInventoriedAs vf:currentLocation );
    ] ;
.

:RuleCopyLocationToNextState_toResource   
    sh:condition [
        sh:path ( vf:toResourceInventoriedAs vf:currentLocation ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:toResourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:currentLocation ;
    sh:object [
        sh:path ( vf:toResourceInventoriedAs vf:currentLocation );
    ] ;
.

:RuleCopyPrimaryAccountableToNextState    
    sh:condition [
        sh:path ( vf:resourceInventoriedAs vf:primaryAccountable ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:resourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:primaryAccountable ;
    sh:object [
        sh:path ( vf:resourceInventoriedAs vf:primaryAccountable );
    ] ;
.

:RuleCopyPrimaryAccountableToNextState_toResource   
    sh:condition [
        sh:path ( vf:toResourceInventoriedAs vf:primaryAccountable ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:toResourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:primaryAccountable ;
    sh:object [
        sh:path ( vf:toResourceInventoriedAs vf:primaryAccountable );
    ] ;
.

:RuleCopyPrimaryAccountableFromEventReceiverToNextState    
    sh:condition [
        sh:path vf:receiver ;
        sh:nodeKind sh:IRI;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:resourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:primaryAccountable ;
    sh:object [
        sh:path vf:receiver ;
    ] ;
    .

:RuleCopyCustodianToNextState    
    sh:condition [
        sh:path ( vf:resourceInventoriedAs vf:custodian ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:resourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:custodian ;
    sh:object [
        sh:path ( vf:resourceInventoriedAs vf:custodian );
    ] ;
.


:RuleCopyCustodianToNextState_toResource   
    sh:condition [
        sh:path ( vf:toResourceInventoriedAs vf:custodian ) ;
        sh:nodeKind sh:IRIOrLiteral;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:toResourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:custodian ;
    sh:object [
        sh:path ( vf:toResourceInventoriedAs vf:custodian );
    ] ;
.

:RuleCopyCustodianFromEventProviderToNextState    
    sh:condition [
        sh:path vf:provider ;
        sh:nodeKind sh:IRI;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:resourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:custodian ;
    sh:object [
        sh:path vf:provider ;
    ] ;
    .

:RuleCopyCustodianFromEventReceiverToNextState    
    sh:condition [
        sh:path vf:receiver ;
        sh:nodeKind sh:IRI;
    ] ;
    a sh:TripleRule ;
    sh:subject [ 
        fn:newNodeURI ( 
            sh:this 
            [ sh:path vf:resourceInventoriedAs ] 
        ) ;
    ] ;
    sh:predicate vf:custodian ;
    sh:object [
        sh:path vf:receiver ;
    ] ;
    .

:RuleCopyOnhandQuantityToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
    .

:RuleCopyOnhandQuantityFromEventToNextState
        sh:condition [
            sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ;
            sh:nodeKind sh:Literal;
        ] ;
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
        .


:RuleCopyAccountingQuantityFromEventToNextState
        sh:condition [
            sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ;
            sh:nodeKind sh:Literal;
        ] ;
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
        .

:RuleCopyOnhandQuantityDecreasedByEventQuantityToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?newValueLiteral
                ] 
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?eventValue 
                ] .
                BIND (
                    fn:getTypedLiteralForOp2(
                        ?value, 
                        ?eventValue, 
                        ?value - ?eventValue) 
                    as ?newValueLiteral
                )
            }""" ;
    .


:RuleCopyAccountingQuantityDecreasedByEventQuantityToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?newValueLiteral
                ] 
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?eventValue 
                ] .
                BIND (
                    fn:getTypedLiteralForOp2(
                        ?value, 
                        ?eventValue, 
                        ?value - ?eventValue) 
                    as ?newValueLiteral
                )
            }""" ;
    .

:RuleCopyAccountingQuantityIncreasedByEventQuantityToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?newValueLiteral
                ] 
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?eventValue 
                ] .
                BIND (
                    fn:getTypedLiteralForOp2(
                        ?value, 
                        ?eventValue, 
                        ?value + ?eventValue) 
                    as ?newValueLiteral
                )
            }""" ;
    .
    
:RuleCopyAccountingQuantityIncreasedByEventQuantityToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?newValueLiteral
                ] 
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?eventValue 
                ]
                BIND (
                    fn:getTypedLiteralForOp2(
                        ?value, 
                        ?eventValue, 
                        ?value + ?eventValue) 
                    as ?newValueLiteral
                )
            }""" ;
    .

:RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?newValueLiteral
                ] 
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?eventValue 
                ]
                BIND (
                    fn:getTypedLiteralForOp2(
                        ?value, 
                        ?eventValue, 
                        ?value + ?eventValue) 
                    as ?newValueLiteral
                )
            }""" ;
    .

:RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?newValueLiteral
                ] 
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?eventValue 
                ]
                BIND (
                    fn:getTypedLiteralForOp2(
                        ?value, 
                        ?eventValue, 
                        ?value + ?eventValue) 
                    as ?newValueLiteral
                )
            }""" ;
    .


:RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?newValueLiteral
                ] 
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
                ?this vf:resourceQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?eventValue 
                ]
                BIND (
                    fn:getTypedLiteralForOp2(
                        ?value, 
                        ?eventValue, 
                        ?value + ?eventValue) 
                    as ?newValueLiteral
                )
            }""" ;
    .

:RuleCopyOnhandQuantityToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  vf:onhandQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
    .


:RuleCopyAccountingQuantityToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
    .

:RuleCopyAccountingQuantityToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] 
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  vf:accountingQuantity [
                    om2:hasUnit ?unit ;
                    om2:hasNumericalValue ?value
                ] .  
            }""" ;
    .

# Any resource properties that are not affected by any events
# are copied here, by explicitly omitting the properties
# that we know are affected by events
:RuleCopyOtherPropertiesToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?p ?o
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  ?p ?o .
                FILTER(!ISBLANK(?o) 
                    && ! ( ?p IN (
                            rdf:type,
                            vf:previousState,
                            vf:currentLocation,
                            vf:onhandQuantity,
                            vf:accountingQuantity,
                            vf:primaryAccountable, 
                            vf:custodian
                            )
                        )
                )
            }""" ;
    .

# Any resource properties that are not affected by any events
# are copied here, by explicitly omitting the properties
# that we know are affected by events
:RuleCopyOtherPropertiesToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?p ?o
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  ?p ?o .
                FILTER(!ISBLANK(?o) 
                    && ! ( ?p IN (
                            rdf:type,
                            vf:previousState,
                            vf:currentLocation,
                            vf:onhandQuantity,
                            vf:accountingQuantity,
                            vf:primaryAccountable,
                            vf:custodian
                            )
                        )
                )
            }""" ;
    .    


# Any resource properties that are not affected by any events
# are copied here, by explicitly omitting the properties
# that we know are affected by events
:RuleCopyOtherPropertiesFromEventToNextState
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?p ?o
            } WHERE {
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?this  ?p ?o .
                FILTER(!ISBLANK(?o) 
                    && ! ( ?p IN (
                            rdf:type,
                            vf:action,
                            vf:atLocation,
                            vf:eventQuantity,
                            vf:receiver,
                            vf:provider
                            )
                        )
                )
            }""" ;
    .




# Any bnode-valued resource properties that are not affected by any events
# are copied here, by explicitly omitting the properties
# that we know are affected by events
:RuleCopyOtherBNodeStructuresToNextState 
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?p ?o .
                ?o ?p2 ?o2 .
                ?o2 ?p3 ?o3 .
                ?o3 ?p4 ?o4 .
                ?o4 ?p5 ?o5 .
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  ?p ?o .
                ?o ?p2 ?o2 . # not optional - what good would an unonnected BNODE be?
                FILTER(ISBLANK(?o) 
                    && ! ( ?p IN (
                            vf:onhandQuantity,
                            vf:accountingQuantity
                            # we do not filter vf:currentLocation in case it's a BNODE structure
                            )
                        )
                )
                OPTIONAL {
                    FILTER (ISBLANK(?o2))
                    ?o2 ?p3 ?o3 
                    OPTIONAL {
                        FILTER (ISBLANK(?o3))
                        ?o3 ?p4 ?o4 
                        OPTIONAL {
                            FILTER (ISBLANK(?o3))
                            ?o4 ?p5 ?o5 
                    }
                    }
                }
            
            }""" ;
    .

# Any bnode-valued resource properties that are not affected by any events
# are copied here, by explicitly omitting the properties
# that we know are affected by events
:RuleCopyOtherBNodeStructuresToNextState_toResource
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?p ?o .
                ?o ?p2 ?o2 .
                ?o2 ?p3 ?o3 .
                ?o3 ?p4 ?o4 .
                ?o4 ?p5 ?o5 .
            } WHERE {
                ?this vf:toResourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  ?p ?o .
                ?o ?p2 ?o2 . # not optional - what good would an unonnected BNODE be?
                FILTER(ISBLANK(?o) 
                    && ! ( ?p IN (
                            vf:onhandQuantity,
                            vf:accountingQuantity
                            # we do not filter vf:currentLocation in case it's a BNODE structure
                            )
                        )
                )
                OPTIONAL {
                    FILTER (ISBLANK(?o2))
                    ?o2 ?p3 ?o3 
                    OPTIONAL {
                        FILTER (ISBLANK(?o3))
                        ?o3 ?p4 ?o4 
                        OPTIONAL {
                            FILTER (ISBLANK(?o3))
                            ?o4 ?p5 ?o5 
                    }
                    }
                }
            
            }""" ;
    .

# Any bnode-valued event properties that are not affected by any events
# are copied here, by explicitly omitting the properties
# that we know are affected by events
:RuleCopyOtherBNodeStructuresFromEventToNextState 
        a sh:SPARQLRule ;
        sh:prefixes vf: ;
        sh:construct """
            CONSTRUCT {
                ?next ?pMapped ?o .
                ?o ?p2 ?o2 .
                ?o2 ?p3 ?o3 .
                ?o3 ?p4 ?o4 .
                ?o4 ?p5 ?o5 .
            } WHERE {
                ?this vf:resourceInventoriedAs ?res .
                BIND(fn:newNodeURI(?this, ?res) as ?next)
                ?res  ?p ?o .
                BIND(IF(?p = vf:atLocation, vf:currentLocation, ?p) as ?pMapped)
                ?o ?p2 ?o2 . # not optional - what good would an unonnected BNODE be?
                FILTER(ISBLANK(?o) 
                    && ! ( ?p IN (
                            vf:eventQuantity,
                            vf:receiver,
                            vf:provider,
                            vf:action
                            # we do not filter vf:atLocation in case it's a BNODE structure
                            # but we have to map the name to vf:currentLocation if that is the case
                            )
                        )
                )
                OPTIONAL {
                    FILTER (ISBLANK(?o2))
                    ?o2 ?p3 ?o3 
                    OPTIONAL {
                        FILTER (ISBLANK(?o3))
                        ?o3 ?p4 ?o4 
                        OPTIONAL {
                            FILTER (ISBLANK(?o3))
                            ?o4 ?p5 ?o5 
                    }
                    }
                }
            
            }""" ;
    .


###############################################################################
#                       vf:EcononomicEvents
###############################################################################


###############################################################################
#                       Events with action `vf:move` 
#
# Change location and possibly identifier, if location is part of the 
# identification, of a resource with no change of agent rights or possession.
###############################################################################

## `vf:move` connected to only one resource

# Invariants for move actions with `vf:resourceInventoriedAs` and NO `vf:toResourceInventoriedAs`:
# - The event must have different `vf:atLocation` value than the resource's `vf:currentLocation` 
# - The event must have a quantity that must be equal to the resource's quantity
# - If the event is not current, the resource states must differ by vf:currentLocation
:EventShape_move
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:move
        ] ;
        sh:expression [
            sh:message "The only property allowed to be affected by a 'move' event is `vf:currentLocation`, but others are, too" ;            
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:currentLocation
                    vf:previousState
                )]
            )
        ] ;
        sh:not [
            sh:message "Event with action 'move': vf:atLocation must be different from resource's vf:currentLocation, but it is not." ; 
            sh:property [
                sh:path vf:atLocation ;
                :sameAsResourceProperty vf:currentLocation ;
                :resourcePath vf:resourceInventoriedAs ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
            ] ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsNextResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :sameAsNextResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :sameAsResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `move` action that has a 
#    `vf:resourceInventoriedAs` and NO
#    `vf:toResourceInventoriedAs` :
# 
# - It generates one new resource states for `resource`
# - It copies all old values but changes the location to the event's location
# - Copying includes blank node structures connected to the resource, 
#   but not infinitely deep (see RuleCopyOtherBNodeStructuresToNextState)
:CurrentEventEffectsShape_move
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:move
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationFromEventToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

## `vf:move` connected to two resources (we also call that 'move2')

# Invariants for move actions with `vf:resourceInventoriedAs` AND `vf:toResourceInventoriedAs`:
# - The event's vf:atLocation` value must be different from the resource's `vf:currentLocation` 
# - The event's vf:atLocation` value must be the same as the toResource's `vf:currentLocation` 
# - The event's `vf:resourcequantity` must not be smaller than the resource's `vf:onhandQuantity`
# - The the resource's `vf:onhandQuantity` must decrement by the event's `vf:resourceQuantity`
# - The the toResource's `vf:onhandQuantity` must increment by the event's `vf:resourceQuantity`
# - The two resources must have the same `vf:primaryAccountable`
# - The successor resources must not differ from their predecessors except in quantity as
#   results from the event quantity

:EventShape_move_toResource 
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_toResource;
            :parAction vf:move
        ] ;
        sh:expression [
            sh:message "The only property allowed to be affected by a 'move2' event is `vf:onhandQuantity`, but others are, too" ;            
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:onhandQuantity
                    vf:previousState
                )]
            )
        ] ;
        sh:expression [
            sh:message "Both or neither resources of a 'move2' event must have the same vf:primaryAccountable, but they" ;
            fn:pathEqualsOrBothEmpty (
                [ sh:path vf:resourceInventoriedAs ]
                vf:primaryAccountable
                [ sh:path vf:toResourceInventoriedAs ]
                vf:primaryAccountable
            )
        ] ;
        sh:expression [
            sh:message "Both or neither resources of a 'move2' event must have the same vf:classifiedAs, but this is not the case." ;
            fn:pathEqualsOrBothEmpty (
                [ sh:path vf:resourceInventoriedAs ]
                vf:classifiedAs
                [ sh:path vf:toResourceInventoriedAs ]
                vf:classifiedAs
            )
        ] ;
        sh:expression [
            sh:message "Both resources of a 'move2' event must have the same vf:onhandQuantity/om2:hasUnit, but this is not the case." ;
            fn:pathEquals (
                [ sh:path (vf:resourceInventoriedAs vf:onhandQuantity )]
                om2:hasUnit 
                [ sh:path (vf:toResourceInventoriedAs vf:onhandQuantity)]
                om2:hasUnit 
            )
        ] ;
        sh:not [
            sh:property [
                sh:path vf:atLocation ;
                    sh:message "Event with action 'move2': vf:atLocation must be different from its resource's vf:currentLocation, but it is not." ; 
                    :sameAsResourceProperty vf:currentLocation ;
                    :sameAsNextResourceProperty vf:currentLocation ;
                    :resourcePath vf:resourceInventoriedAs ;
                sh:minCount 1 ;
                sh:maxCount 1 ;
            ] ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsNextResourceProperty vf:currentLocation ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:expression [
            sh:message "Both or neither resources of a 'move2' event must have the same vf:primaryAccountable, but this is not the case" ;
            fn:pathEqualsOrBothEmpty (
                [ sh:path vf:resourceInventoriedAs ]
                vf:primaryAccountable
                [ sh:path vf:toResourceInventoriedAs ]
                vf:primaryAccountable
            )
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            :allowResultBelowZero false ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .

# Effect of a current `move` action that has a 
#    `vf:resourceInventoriedAs` and a
#    `vf:toResourceInventoriedAs` :
# 
# It generates new resource states for `resource` and `toResource`
#   - sets both `vf:onhandQuantity` based on the event `vf:resourceQuantity`
# 
:CurrentEventEffectsShape_move_toResource
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget_toResource ;
            :parAction vf:move
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleCreateNextState_toResource ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleLinkFromNextState_toResource ;
        sh:rule :RuleCopyOnhandQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState_toResource ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState_toResource ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyLocationToNextState_toResource ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyPrimaryAccountableToNextState_toResource ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState_toResource ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState_toResource ;
        .




###############################################################################
#                       Events with action `vf:transfer` 
#
#  Give full rights and responsibilities plus physical custody.
###############################################################################

## `vf:transfer` connected to only one resource

# Invariants for transfer actions with `vf:resourceInventoriedAs` and NO `vf:toResourceInventoriedAs`:
# - The event's `vf:receiver`must be different from the resource's `vf:primaryAccountable` 
# - The event's `vf:provider`must be the same as the resource's `vf:primaryAccountable` 
# - The event's `vf:provider`must be the same as the resource's `vf:custodian` 
# - The event's `vf:resourceQuantity` must be the same as the resource's `vf:onhandQuantity` and `vf:accountingQuantity` 
# - If the event is not current, the resource states must differ by vf:`primaryAccountable`
# - If the event is not current, the resource states must differ by vf:`custodian`
# - The event's `vf:atLocation` must be the same as the resource's `vf:currentLocation`
:EventShape_transfer
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:transfer
        ] ;
        sh:expression [
            sh:message "The only properties allowed to be affected by a 'transfer' event are `vf:primaryAccountable` and `vf:custodian`, but others are, too" ;            
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:primaryAccountable
                    vf:custodian
                )]
            )
        ] ;
        sh:expression [
            sh:message "A 'transfer' event is only allowed if the resource's onhand and accounting quantities are equal ." ;
            fn:and (
                [ fn:equals ( 
                    [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
                    [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
                )]
                [ fn:equals ( 
                    [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue )]
                    [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasNumericalValue )]
                )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceQuantity ;
            :sameAsResourceProperty vf:accountingQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:provider ;
            :sameAsResourceProperty vf:primaryAccountable ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:provider ;
            :sameAsResourceProperty vf:custodian ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:receiver ;
            :sameAsNextResourceProperty vf:primaryAccountable ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:receiver ;
            :sameAsNextResourceProperty vf:custodian ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;        
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;


        .


# Effect of a current `transfer` action that has a 
#    `vf:resourceInventoriedAs` and NO
#    `vf:toResourceInventoriedAs` :
# 
# - It generates one new resource states for `resource`
# - It copies all old values but changes the `vf:primaryAccountable` and `vf:custodian` properties
# - Copying includes blank node structures connected to the resource, 
#   but not infinitely deep (see RuleCopyOtherBNodeStructuresToNextState)
:CurrentEventEffectsShape_transfer
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:transfer
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationFromEventToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableFromEventReceiverToNextState ;
        sh:rule :RuleCopyCustodianFromEventReceiverToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

## `vf:transfer` connected to two resources (we also call that 'transfer2')

# Invariants for transfer actions with `vf:resourceInventoriedAs` AND `vf:toResourceInventoriedAs`:
# - The event's vf:atLocation` value must be the same as `vf:currentLocation` 
# - The event's vf:atLocation` value must be the same as toResource's `vf:currentLocation` 
# - The event's `vf:resourcequantity` must not be smaller than the resource's `vf:onhandQuantity`
# - The the resource's `vf:onhandQuantity` must decrement by the event's `vf:resourceQuantity`
# - The the resource's `vf:accountingQuantity` must decrement by the event's `vf:resourceQuantity`
# - The the toResource's `vf:onhandQuantity` must increment by the event's `vf:resourceQuantity`
# - The the toResource's `vf:accountingQuantity` must increment by the event's `vf:resourceQuantity`
# - The event's `vf:provider`must be the same as the resource's `vf:primaryAccountable` 
# - The event's `vf:provider`must be the same as the resource's `vf:custodian` 
# - The event's `vf:receiver`must be the same as the toResource's `vf:primaryAccountable` 
# - The event's `vf:receiver`must be the same as the toResource's `vf:custodian` 
# - The successor resources must not differ from their predecessors except in quantity, custodian and primaryAccountable


:EventShape_transfer_toResource 
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_toResource;
            :parAction vf:transfer
        ] ;
        sh:expression [
            sh:message "The only properties allowed to be affected by a 'transfer2' are vf:onhandQuantity, vf:accountingQuantity, vf:custodian, vf:primaryAccountable, but others are, too" ;            
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:onhandQuantity
                    vf:accountingQuantity
                    vf:previousState
                )]
            )
        ] ;
        sh:property [
            sh:path vf:provider ;
            :sameAsResourceProperty vf:primaryAccountable ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:provider ;
            :sameAsResourceProperty vf:custodian ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:receiver ;
            :sameAsResourceProperty vf:primaryAccountable ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:receiver ;
            :sameAsResourceProperty vf:custodian ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            :allowResultBelowZero false ;            
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:accountingQuantity ;
            :allowResultBelowZero false ;            
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:accountingQuantity ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .

# Effect of a current `transfer` action that has a 
#    `vf:resourceInventoriedAs` and a
#    `vf:toResourceInventoriedAs` :
# 
# It generates new resource states for `resource` and `toResource`
#   - sets both `vf:onhandQuantity` based on the event `vf:resourceQuantity`
# 
:CurrentEventEffectsShape_transfer_toResource
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget_toResource ;
            :parAction vf:transfer
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleCreateNextState_toResource ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleLinkFromNextState_toResource ;
        sh:rule :RuleCopyOnhandQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState_toResource ;
        sh:rule :RuleCopyAccountingQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityIncreasedByEventQuantityToNextState_toResource ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyLocationToNextState_toResource ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyPrimaryAccountableToNextState_toResource ;
        sh:rule :RuleCopyCustodianToNextState ;
        sh:rule :RuleCopyCustodianToNextState_toResource ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState_toResource ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState_toResource ;
        .





###############################################################################
#                       Events with action `vf:transfer-custody` 
#
#  Give physical custody and control of a resource, without full accounting or ownership rights.
###############################################################################

## `vf:transfer-custody` connected to only one resource

# Invariants for transfer-custody actions with `vf:resourceInventoriedAs` and NO `vf:toResourceInventoriedAs`:
# - The event's `vf:receiver`must be different from the resource's `vf:custodian` 
# - The event's `vf:provider`must be the same as the resource's `vf:custodian` 
# - The event's `vf:resourceQuantity` must be the same as the resource's `vf:onhandQuantity` and `vf:accountingQuantity` 
# - If the event is not current, the resource states must differ by vf:`custodian`
# - The event's `vf:atLocation` must be the same as the resource's `vf:currentLocation`
:EventShape_transfer-custody
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:transfer-custody
        ] ;
        sh:expression [
            sh:message "The only properties allowed to be affected by a 'transfer-custody' event are `vf:primaryAccountable` and `vf:custodian`, but others are, too" ;            
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:custodian
                )]
            )
        ] ;
        sh:expression [
            sh:message "A 'transfer-custody' event is only allowed if the resource's onhand and accounting quantities are equal ." ;
            fn:and (
                [ fn:equals ( 
                    [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
                    [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
                )]
                [ fn:equals ( 
                    [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue )]
                    [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasNumericalValue )]
                )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceQuantity ;
            :sameAsResourceProperty vf:accountingQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:provider ;
            :sameAsResourceProperty vf:custodian ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
       sh:property [
            sh:path vf:receiver ;
            :sameAsNextResourceProperty vf:custodian ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;        
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;


        .


# Effect of a current `transfer-custody` action that has a 
#    `vf:resourceInventoriedAs` and NO
#    `vf:toResourceInventoriedAs` :
# 
# - It generates one new resource states for `resource`
# - It copies all old values but changes the `vf:primaryAccountable` and `vf:custodian` properties
# - Copying includes blank node structures connected to the resource, 
#   but not infinitely deep (see RuleCopyOtherBNodeStructuresToNextState)
:CurrentEventEffectsShape_transfer-custody
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:transfer-custody
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationFromEventToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyCustodianFromEventReceiverToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

## `vf:transfer-custody` connected to two resources (we also call that 'transfer-custody2')

# Invariants for transfer-custody actions with `vf:resourceInventoriedAs` AND `vf:toResourceInventoriedAs`:
# - The event's vf:atLocation` value must be the same as `vf:currentLocation` 
# - The event's vf:atLocation` value must be the same as toResource's `vf:currentLocation` 
# - The event's `vf:resourceQuantity` must not be smaller than the resource's `vf:onhandQuantity`
# - The the resource's `vf:onhandQuantity` must decrement by the event's `vf:resourceQuantity`
# - The the resource's `vf:accountingQuantity` must not change
# - The the toResource's `vf:onhandQuantity` must increment by the event's `vf:resourceQuantity`
# - The the toResource's `vf:accountingQuantity` must not change
# - The event's `vf:provider`must be the same as the resource's `vf:custodian` 
# - The event's `vf:receiver`must be the same as the toResource's `vf:custodian` 
# - The successor resources must not differ from their predecessors except in quantity, custodian and primaryAccountable


:EventShape_transfer-custody_toResource 
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_toResource;
            :parAction vf:transfer-custody
        ] ;
        sh:expression [
            sh:message "The only properties allowed to be affected by a 'transfer-custody2' are vf:onhandQuantity, vf:accountingQuantity, vf:custodian, vf:primaryAccountable, but others are, too" ;            
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:onhandQuantity
                    vf:accountingQuantity
                    vf:previousState
                )]
            )
        ] ;
        sh:property [
            sh:path vf:provider ;
            :sameAsResourceProperty vf:custodian ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:receiver ;
            :sameAsResourceProperty vf:custodian ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            :allowResultBelowZero false ;            
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .

# Effect of a current `transfer-custody` action that has a 
#    `vf:resourceInventoriedAs` and a
#    `vf:toResourceInventoriedAs` :
# 
# It generates new resource states for `resource` and `toResource`
#   - sets both `vf:onhandQuantity` based on the event `vf:resourceQuantity`
# 
:CurrentEventEffectsShape_transfer-custody_toResource
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget_toResource ;
            :parAction vf:transfer-custody
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleCreateNextState_toResource ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleLinkFromNextState_toResource ;
        sh:rule :RuleCopyOnhandQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState_toResource ;
        sh:rule :RuleCopyAccountingQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityIncreasedByEventQuantityToNextState_toResource ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyLocationToNextState_toResource ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyPrimaryAccountableToNextState_toResource ;
        sh:rule :RuleCopyCustodianToNextState ;
        sh:rule :RuleCopyCustodianToNextState_toResource ;        
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState_toResource ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState_toResource ;
        .






###############################################################################
#                       Events with action `vf:transfer-all-rights` 
#
#  Give full rights and responsibilities plus physical custody.
###############################################################################

## `vf:transfer-all-rights` connected to only one resource

# Invariants for transfer-all-rights actions with `vf:resourceInventoriedAs` and NO `vf:toResourceInventoriedAs`:
# - The event's `vf:receiver`must be different from the resource's `vf:primaryAccountable` 
# - The event's `vf:provider`must be the same as the resource's `vf:primaryAccountable` 
# - The event's `vf:resourceQuantity` must be the same as the resource's `vf:onhandQuantity` and `vf:accountingQuantity` 
# - If the event is not current, the resource states must differ by vf:`primaryAccountable`
# - The event's `vf:atLocation` must be the same as the resource's `vf:currentLocation`
:EventShape_transfer-all-rights
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:transfer-all-rights
        ] ;
        sh:expression [
            sh:message "The only properties allowed to be affected by a 'transfer-all-rights' event are `vf:primaryAccountable` and `vf:custodian`, but others are, too" ;            
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:primaryAccountable
                )]
            )
        ] ;
        sh:expression [
            sh:message "A 'transfer-all-rights' event is only allowed if the resource's onhand and accounting quantities are equal ." ;
            fn:and (
                [ fn:equals ( 
                    [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
                    [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
                )]
                [ fn:equals ( 
                    [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue )]
                    [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasNumericalValue )]
                )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceQuantity ;
            :sameAsResourceProperty vf:accountingQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:provider ;
            :sameAsResourceProperty vf:primaryAccountable ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:receiver ;
            :sameAsNextResourceProperty vf:primaryAccountable ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;


        .


# Effect of a current `transfer-all-rights` action that has a 
#    `vf:resourceInventoriedAs` and NO
#    `vf:toResourceInventoriedAs` :
# 
# - It generates one new resource states for `resource`
# - It copies all old values but changes the `vf:primaryAccountable` and `vf:custodian` properties
# - Copying includes blank node structures connected to the resource, 
#   but not infinitely deep (see RuleCopyOtherBNodeStructuresToNextState)
:CurrentEventEffectsShape_transfer-all-rights
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:transfer-all-rights
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationFromEventToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableFromEventReceiverToNextState ;
        sh:rule :RuleCopyCustodianToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

## `vf:transfer-all-rights` connected to two resources (we also call that 'transfer-all-rights2')

# Invariants for transfer-all-rights actions with `vf:resourceInventoriedAs` AND `vf:toResourceInventoriedAs`:
# - The event's vf:atLocation` value must be the same as `vf:currentLocation` 
# - The event's vf:atLocation` value must be the same as toResource's `vf:currentLocation` 
# - The event's `vf:resourcequantity` must not be smaller than the resource's `vf:accountingQuantity`
# - The the resource's `vf:onhandQuantity` must not change
# - The the resource's `vf:accountingQuantity` must decrement by the event's `vf:resourceQuantity`
# - The the toResource's `vf:onhandQuantity` must not change
# - The the toResource's `vf:accountingQuantity` must increment by the event's `vf:resourceQuantity`
# - The event's `vf:provider`must be the same as the resource's `vf:primaryAccountable` 
# - The event's `vf:receiver`must be the same as the toResource's `vf:primaryAccountable` 
# - The successor resources must not differ from their predecessors except in quantity


:EventShape_transfer-all-rights_toResource 
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_toResource;
            :parAction vf:transfer-all-rights
        ] ;
        sh:expression [
            sh:message "The only properties allowed to be affected by a 'transfer-all-rights2' are vf:onhandQuantity, vf:accountingQuantity, vf:custodian, vf:primaryAccountable, but others are, too" ;            
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:accountingQuantity
                    vf:previousState
                )]
            )
        ] ;
        sh:property [
            sh:path vf:provider ;
            :sameAsResourceProperty vf:primaryAccountable ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:receiver ;
            :sameAsResourceProperty vf:primaryAccountable ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:accountingQuantity ;
            :allowResultBelowZero false ;            
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:accountingQuantity ;
            :resourcePath vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .

# Effect of a current `transfer-all-rights` action that has a 
#    `vf:resourceInventoriedAs` and a
#    `vf:toResourceInventoriedAs` :
# 
# It generates new resource states for `resource` and `toResource`
#   - sets both `vf:onhandQuantity` based on the event `vf:resourceQuantity`
# 
:CurrentEventEffectsShape_transfer-all-rights_toResource
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget_toResource ;
            :parAction vf:transfer-all-rights
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleCreateNextState_toResource ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleLinkFromNextState_toResource ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState_toResource ;
        sh:rule :RuleCopyAccountingQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityIncreasedByEventQuantityToNextState_toResource ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyLocationToNextState_toResource ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyPrimaryAccountableToNextState_toResource ;
        sh:rule :RuleCopyCustodianToNextState ;
        sh:rule :RuleCopyCustodianToNextState_toResource ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState_toResource ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState_toResource ;
        .







###############################################################################
#                       Events with action `vf:produce` 
#
#  (New resource was created in that process or) an existing stock resource was
#  added to.
#
#  This action is the only one that can create a resource. It is not specified
#  in the documentation how exactly that works. The case in which quantity is 
#  just added to an existing resource is not a problem - essentially identical 
#  to vf:add. 
#  The optionas are:
#  * There is no resource prior to the event
#       - Option A: the event references the URI of the new resource via 
#         `vf:resourceInventoriedAs`; the framework then generates the rest 
#          of the data.
#        - Option B: the event does not use `vf:resourceInventoriedAs`
#          The framework generates the resource URI, its data and links it to
#          the event.
#  * Option C: Prior to the `vf:produce` event, there MUST be a new, prepared, 
#    empty resource already.
#  
#  Here, we wanted to choose option B. Reasoning: with C, there is no difference
#  to `vf:add` and we are still left unsure how resources ever start to exist. 
#  B allows for C as the case in which `vf:produce` is essentially `vf:add`, but 
#  maybe somehow still different (we'll see if that turns out to be true).
#
#  However it turned out that many other events can create resources, and the
#  resulting complication for verification doesn't seem to be worth it. So:
#
#  After some thought: We'll try to do it this way and see what we end up with:
#  * Only a 'create' action can create a resource.
#  * Only a 'destroy' action can cause a resource to cease to exist. (if needed)
#  * Non-flow properties are set by an 'edit' action.
# 
#  Consequence: `vf:produce` cannot create a resource
#
###############################################################################

# Invariants for `vf:produce` actions
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - The event must have a quantity > 0
# - The event must have the same unit of measurement as the resource
# - The event's quantity must increase the resource's next state
# - The event's `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_produce
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:produce
        ] ;
        sh:expression [
            sh:message "A 'produce' event may only affect vf:onhandQuantity and vf:accountingQuantity, but other are affected, too." ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:onhandQuantity
                    vf:accountingQuantity
                )]
            )
        ] ;
        sh:expression [
            sh:message "A 'produce' event must have a positive quantity." ;
            fn:greaterThan ( 
                [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                0 
            )
        ] ;
        sh:expression [
            sh:message "A 'produce' event must use the same units as its resource/onhand quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
            )
        ] ;        
        sh:expression [
            sh:message "A 'produce' event must use the same units as its resource/accounting quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:accountingQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `produce` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values but changes accounting and onhand quantities by 
#   the event's quantities
:CurrentEventEffectsShape_produce
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:produce
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityIncreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

###############################################################################
#                       Events with action `vf:raise` 
# Adjusts a quantity up based on a beginning balance or inventory count.
###############################################################################

# Invariants for `vf:raise` actions
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - The event must have a quantity > 0
# - The event must have the same unit of measurement as the resource
# - The event's quantity must increase the resource's next state
# - The event's `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_raise
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:raise
        ] ;
        sh:expression [
            sh:message "A 'raise' event may only affect vf:onhandQuantity and vf:accountingQuantity, but other are affected, too." ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:onhandQuantity
                    vf:accountingQuantity
                )]
            )
        ] ;
        sh:expression [
            sh:message "A 'raise' event must have a positive quantity." ;
            fn:greaterThan ( 
                [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                0 
            )
        ] ;
        sh:expression [
            sh:message "A 'raise' event must use the same units as its resource/onhand quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
            )
        ] ;        
        sh:expression [
            sh:message "A 'raise' event must use the same units as its resource/accounting quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:accountingQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `raise` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values but changes accounting and onhand quantities by 
#   the event's quantities
:CurrentEventEffectsShape_raise
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:raise
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityIncreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

###############################################################################
#                       Events with action `vf:modify` 
#  In processes like repair or modification, the same resource will appear 
#  in the input.
###############################################################################

# Invariants for `vf:modify` actions
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - The event must have a quantity > 0
# - The event must have the same unit of measurement as the resource
# - The event's quantity must increase the resource's next state (only `vf:onhandQuantity`)
# - The event's `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_modify
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:modify
        ] ;
        sh:expression [
            sh:message "A 'modify' event may only affect vf:onhandQuantity and vf:accountingQuantity, but other are affected, too." ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:onhandQuantity
                )]
            )
        ] ;
        sh:expression [
            sh:message "A 'modify' event must have a positive quantity." ;
            fn:greaterThan ( 
                [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                0 
            )
        ] ;
        sh:expression [
            sh:message "A 'modify' event must use the same units as its resource/onhand quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
            )
        ] ;        
        sh:expression [
            sh:message "A 'modify' event must use the same units as its resource/accounting quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventIncreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `modify` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values but changes accounting and onhand quantities by 
#   the event's quantities
:CurrentEventEffectsShape_modify
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:modify
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityIncreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

###############################################################################
#                       Events with action `vf:consume` 
#  For example an ingredient or component composed into the output, after the process 
#  the ingredient is gone.
#  We reinterpret this as simple lowering effect, opposite of consume
###############################################################################

# Invariants for `vf:consume` actions
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - The event must have a quantity > 0
# - The resource must have a onhand/accounting quantity greater than the event's quantity.
# - The event must have the same unit of measurement as the resource
# - The event's quantity must decrease the resource's next state
# - The event's `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_consume
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:consume
        ] ;
        sh:expression [
            sh:message "A 'consume' event may only affect vf:onhandQuantity and vf:accountingQuantity, but other are affected, too." ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:onhandQuantity
                    vf:accountingQuantity
                )]
            )
        ] ;
        sh:expression [
            sh:message "A 'consume' event must have a positive quantity." ;
            fn:greaterThan ( 
                [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                0 
            )
        ] ;
        sh:expression [
            sh:message "A 'consume' event must use the same units as its resource/onhand quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
            )
        ] ;        
        sh:expression [
            sh:message "A 'consume' event must use the same units as its resource/accounting quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            :allowResultBelowZero false ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:accountingQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            :allowResultBelowZero false ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `consume` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values but decreases accounting and onhand quantities by 
#   the event's quantities
:CurrentEventEffectsShape_consume
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:consume
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .




###############################################################################
#                       Events with action `vf:lower` 
#  For example an ingredient or component composed into the output, after the process 
#  the ingredient is gone.
#  We reinterpret this as simple lowering effect, opposite of lower
###############################################################################

# Invariants for `vf:lower` actions
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - The event must have a quantity > 0
# - The resource must have a onhand/accounting quantity greater than the event's quantity.
# - The event must have the same unit of measurement as the resource
# - The event's quantity must decrease the resource's next state
# - The event's `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_lower
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:lower
        ] ;
        sh:expression [
            sh:message "A 'lower' event may only affect vf:onhandQuantity and vf:accountingQuantity, but other are affected, too." ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:onhandQuantity
                    vf:accountingQuantity
                )]
            )
        ] ;
        sh:expression [
            sh:message "A 'lower' event must have a positive quantity." ;
            fn:greaterThan ( 
                [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                0 
            )
        ] ;
        sh:expression [
            sh:message "A 'lower' event must use the same units as its resource/onhand quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
            )
        ] ;        
        sh:expression [
            sh:message "A 'lower' event must use the same units as its resource/accounting quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            :allowResultBelowZero false ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:accountingQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            :allowResultBelowZero false ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `lower` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values but decreases accounting and onhand quantities by 
#   the event's quantities
:CurrentEventEffectsShape_lower
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:lower
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .


###############################################################################
#                       Events with action `vf:accept` 
#  In processes like repair or modification or testing, the same resource 
#  will appear in the output.
###############################################################################

# Invariants for `vf:accept` actions
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - The event must have a quantity > 0
# - The resource must have a onhand/accounting quantity greater than the event's quantity.
# - The event must have the same unit of measurement as the resource
# - The event's quantity must decrease the resource's next state (only vf:onhandQuantity`)
# - The event's `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_accept
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:accept
        ] ;
        sh:expression [
            sh:message "A 'accept' event may only affect vf:onhandQuantity and vf:accountingQuantity, but other are affected, too." ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                [ fn:stringConcatWithSpace (
                    vf:onhandQuantity
                )]
            )
        ] ;
        sh:expression [
            sh:message "A 'accept' event must have a positive quantity." ;
            fn:greaterThan ( 
                [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                0 
            )
        ] ;
        sh:expression [
            sh:message "A 'accept' event must use the same units as its resource/onhand quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
            )
        ] ;        
        sh:expression [
            sh:message "A 'accept' event must use the same units as its resource/accounting quantity, but this is not the case." ;
            fn:equals ( 
                [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :eventDecreasesResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            :allowResultBelowZero false ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `accept` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values but decreases accounting and onhand quantities by 
#   the event's quantities
:CurrentEventEffectsShape_accept
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:accept
        ] ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityDecreasedByEventQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .


###############################################################################
#                       Events with action `vf:use` 
###############################################################################

# Invariants: nothing changes
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - If the event has a quantity:
#   * The resource must have a onhand/accounting quantity greater than the event's quantity.
#   * The event must have the same unit of measurement as the resource
# - The event's quantity must not affect the resource quantity.
# - If present, the `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_use
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:use
        ] ;
        a           sh:NodeShape ;
        sh:class    vf:EconomicEvent ;
        sh:expression [
            sh:message "A 'use' event may not affect any resource properties, but this one does" ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                # no properties are exempt - they all have to stay the same
            )
        ] ;
        sh:expression [
            sh:message "If a 'use' event has a quantity, it must use the same units as its resource/onhand quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        "0"^^xsd:int 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;      
        sh:expression [
            sh:message "If a 'use' event has a quantity, it must use the same units as its resource/accounting quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [ fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        0 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 0 ; 
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `use` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values 
:CurrentEventEffectsShape_use
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:use
        ] ;

        a           sh:NodeShape ;
        sh:class vf:EconomicEvent ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

###############################################################################
#                       Events with action `vf:work` 
#  Labor power applied to a process.
###############################################################################

# Invariants: nothing changes
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - If the event has a quantity:
#   * The resource must have a onhand/accounting quantity greater than the event's quantity.
#   * The event must have the same unit of measurement as the resource
# - The event's quantity must not affect the resource quantity.
# - If present, the `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_work
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:work
        ] ;
        a           sh:NodeShape ;
        sh:class    vf:EconomicEvent ;
        sh:expression [
            sh:message "A 'work' event may not affect any resource properties, but this one does" ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                # no properties are exempt - they all have to stay the same
            )
        ] ;
        sh:expression [
            sh:message "If a 'work' event has a quantity, it must work the same units as its resource/onhand quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        "0"^^xsd:int 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;      
        sh:expression [
            sh:message "If a 'work' event has a quantity, it must work the same units as its resource/accounting quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [ fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        0 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 0 ; 
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `work` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values 
:CurrentEventEffectsShape_work
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:work
        ] ;

        a           sh:NodeShape ;
        sh:class vf:EconomicEvent ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

###############################################################################
#                       Events with action `vf:cite` 
#  For example a design file, neither used nor consumed, the file remains 
#  available at all times.
###############################################################################

# Invariants: nothing changes
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - If the event has a quantity:
#   * The resource must have a onhand/accounting quantity greater than the event's quantity.
#   * The event must have the same unit of measurement as the resource
# - The event's quantity must not affect the resource quantity.
# - If present, the `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_cite
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:cite
        ] ;
        a           sh:NodeShape ;
        sh:class    vf:EconomicEvent ;
        sh:expression [
            sh:message "A 'cite' event may not affect any resource properties, but this one does" ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                # no properties are exempt - they all have to stay the same
            )
        ] ;
        sh:expression [
            sh:message "If a 'cite' event has a quantity, it must cite the same units as its resource/onhand quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        "0"^^xsd:int 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;      
        sh:expression [
            sh:message "If a 'cite' event has a quantity, it must cite the same units as its resource/accounting quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [ fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        0 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 0 ; 
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `cite` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values 
:CurrentEventEffectsShape_cite
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:cite
        ] ;

        a           sh:NodeShape ;
        sh:class vf:EconomicEvent ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

###############################################################################
#                       Events with action `vf:pickup` 
#  Transported resource or person enters the process; the same resource 
#  will appear in the output.
###############################################################################

# Invariants: nothing changes
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - If the event has a quantity:
#   * The resource must have a onhand/accounting quantity greater than the event's quantity.
#   * The event must have the same unit of measurement as the resource
# - The event's quantity must not affect the resource quantity.
# - If present, the `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_pickup
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:pickup
        ] ;
        a           sh:NodeShape ;
        sh:class    vf:EconomicEvent ;
        sh:expression [
            sh:message "A 'pickup' event may not affect any resource properties, but this one does" ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                # no properties are exempt - they all have to stay the same
            )
        ] ;
        sh:expression [
            sh:message "If a 'pickup' event has a quantity, it must pickup the same units as its resource/onhand quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        "0"^^xsd:int 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;      
        sh:expression [
            sh:message "If a 'pickup' event has a quantity, it must pickup the same units as its resource/accounting quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [ fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        0 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 0 ; 
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `pickup` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values 
:CurrentEventEffectsShape_pickup
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:pickup
        ] ;

        a           sh:NodeShape ;
        sh:class vf:EconomicEvent ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

###############################################################################
#                       Events with action `vf:dropoff` 
#  Transported resource or person leaves the process; the same resource or 
#  person appeared in the input.
###############################################################################

# Invariants: nothing changes
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - If the event has a quantity:
#   * The resource must have a onhand/accounting quantity greater than the event's quantity.
#   * The event must have the same unit of measurement as the resource
# - The event's quantity must not affect the resource quantity.
# - If present, the `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_dropoff
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:dropoff
        ] ;
        a           sh:NodeShape ;
        sh:class    vf:EconomicEvent ;
        sh:expression [
            sh:message "A 'dropoff' event may not affect any resource properties, but this one does" ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                # no properties are exempt - they all have to stay the same
            )
        ] ;
        sh:expression [
            sh:message "If a 'dropoff' event has a quantity, it must dropoff the same units as its resource/onhand quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        "0"^^xsd:int 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;      
        sh:expression [
            sh:message "If a 'dropoff' event has a quantity, it must dropoff the same units as its resource/accounting quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [ fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        0 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 0 ; 
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `dropoff` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values 
:CurrentEventEffectsShape_dropoff
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:dropoff
        ] ;

        a           sh:NodeShape ;
        sh:class vf:EconomicEvent ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .

###############################################################################
#                       Events with action `vf:deliver-service` 
###############################################################################

# Invariants: nothing changes
# - The event must have a `vf:resourceInventoriedAs` (and it must exist)
# - The event must have the same `vf:atLocation` as the `vf:currentLocation` of the resource
# - If the event has a quantity:
#   * The resource must have a onhand/accounting quantity greater than the event's quantity.
#   * The event must have the same unit of measurement as the resource
# - The event's quantity must not affect the resource quantity.
# - If present, the `vf:resourceClassifiedAs` must be equal to the resource's `vf:classifiedAs`

:EventShape_deliver-service
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource;
            :parAction vf:deliver-service
        ] ;
        a           sh:NodeShape ;
        sh:class    vf:EconomicEvent ;
        sh:expression [
            sh:message "A 'deliver-service' event may not affect any resource properties, but this one does" ;
            :affectsNoResourcePropertiesExcept (
                sh:this 
                # no properties are exempt - they all have to stay the same
            )
        ] ;
        sh:expression [
            sh:message "If a 'deliver-service' event has a quantity, it must deliver-service the same units as its resource/onhand quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        "0"^^xsd:int 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;      
        sh:expression [
            sh:message "If a 'deliver-service' event has a quantity, it must deliver-service the same units as its resource/accounting quantity and the resource must have a greater or equal quantity, but this is not the case." ;
            fn:or (
                [ fn:not ( 
                    [ fn:bound ( 
                        [ sh:path vf:resourceQuantity ] 
                    )]
                )]
                [ fn:and (
                    [ fn:greaterThan ( 
                       [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                        0 
                    )]
                    [ fn:greaterThanOrEquals (
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasNumericalValue )]
                        [ sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ]
                    )]
                    [ fn:equals ( 
                        [ sh:path ( vf:resourceInventoriedAs vf:accountingQuantity om2:hasUnit )]
                        [ sh:path ( vf:resourceQuantity om2:hasUnit ) ]
                    )]
                )]
            )
        ] ;        
        sh:property [
            sh:path vf:resourceClassifiedAs ;
            :sameAsResourceProperty vf:classifiedAs ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 0 ; 
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            :sameAsResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        .


# Effect of a current `deliver-service` action 
# 
# - It generates one new resource state for its resource
# - It copies all old values 
:CurrentEventEffectsShape_deliver-service
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsTarget ;
            :parAction vf:deliver-service
        ] ;

        a           sh:NodeShape ;
        sh:class vf:EconomicEvent ;
        sh:rule :RuleCreateNextState ;
        sh:rule :RuleLinkFromNextState ;
        sh:rule :RuleCopyLocationToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableToNextState ;
        sh:rule :RuleCopyOnhandQuantityToNextState ;
        sh:rule :RuleCopyAccountingQuantityToNextState ;
        sh:rule :RuleCopyOtherPropertiesToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresToNextState ;
        .


###############################################################################
#                       Events with action `vf:create` 
###############################################################################
#
# Invariants for create actions:
# * Either the `vf:resourceInventoriedAs` triple is not there. Then:
#       - I cannot think of any specific invariants
#       - The new resource will be inferred
# * Or the `vf:resourceInventoriedAs` is present. Then:
#       - [event]/`vf:atLocation` = [resource]/`vf:currentLocation` 
#       - [event]/`vf:resourceClassifiedAs` = [resource]/`vf:classifiedAs`
#       - [event]/`vf:receiver` = [resource]/`vf:primaryAccountable` # so we can model that A produces X for B
#       - [event]/`vf:provider` = [resource]/`vf:custodian` # experimental
#       - [event]/`vf:resourceQuantity` =deep= [resource]/`vf:onhandQuantity
#       - [event]/`vf:accountingQuantity` =deep= [resource]/`vf:accountingQuantity
:EventShape_create
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noToResource; 
            :parAction vf:create
        ] ;
        
        sh:property [
            sh:path vf:atLocation ;
            :sameAsNextResourceProperty vf:currentLocation ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :sameAsNextResourceProperty vf:onhandQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceQuantity ;
            :sameAsNextResourceProperty vf:accountingQuantity ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:receiver ;
            :sameAsNextResourceProperty vf:primaryAccountable ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;        
        sh:property [
            sh:path vf:provider ;
            :sameAsNextResourceProperty vf:custodian ;
            :resourcePath vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;                
        .


# Effect of a current `create` action, which is
# a `vf:create` action that does not yet have a
# `vf:resourceInventoriedAs` 
#
# This is a bit tricky:
# We want each resource to have only one event associated with it. That event
# causes the next resource state. Now 'create' is special because if we
# take a current create event, generate the resource, and then link it 
# to the event, the resource has already one event attached and cannot
# get another one that modifies it later. So instead, the 'create' event
# has to create two resources. The first one can be empty - a blank node sounds
# reasonable. That is the one we link to the event. Then, we can generate a 
# next state of that resource, applying all the effects of the create event.
# 
# So here is what happens with a current create event:
# - It generates a new blank node of type `vf:EconomicResource` (call that R0)
# - It links the event to R0
# - It generates one new resource state R1 for R0 and links it using `vf:previousState`
# - It copies all data from the event to the resource (as usual)
# - Copying includes blank node structures connected to the resource, 
#   but not infinitely deep (see RuleCopyOtherBNodeStructuresToNextState)
#
:CurrentEventEffectsShape_create
        a           sh:NodeShape ;
        sh:target [
            a :EventsTarget_noResource ;
            :parAction vf:create
        ] ;
        sh:rule :RuleCreateInitialAndNextState ;
        sh:rule :RuleCopyLocationFromEventToNextState ; 
        sh:rule :RuleCopyPrimaryAccountableFromEventReceiverToNextState ;
        sh:rule :RuleCopyCustodianFromEventProviderToNextState ;
        sh:rule :RuleCopyOnhandQuantityFromEventToNextState ;
        sh:rule :RuleCopyAccountingQuantityFromEventToNextState ;
        sh:rule :RuleCopyOtherPropertiesFromEventToNextState ;
        sh:rule :RuleCopyOtherBNodeStructuresFromEventToNextState ;
        .
