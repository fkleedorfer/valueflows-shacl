@prefix dfc:   <http://www.virtual-assembly.org/DataFoodConsortium/BusinessOntology#> .
@prefix owl:   <http://www.w3.org/2002/07/owl#> .
@prefix org:   <http://www.w3.org/ns/org#> .
@prefix xsd:   <http://www.w3.org/2001/XMLSchema#> .
@prefix dtype: <http://www.linkedmodel.org/schema/dtype#> .
@prefix skos:  <http://www.w3.org/2004/02/skos/core#> .
@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .
@prefix geo:   <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix vf:    <https://w3id.org/valueflows#> .
@prefix sh:    <http://www.w3.org/ns/shacl#> .
@prefix om2:   <http://www.ontology-of-units-of-measure.org/resource/om-2/> .
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix time:  <http://www.w3.org/2006/time#> .
@prefix vs:    <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .
@prefix om2: <http://www.ontology-of-units-of-measure.org/resource/om-2/> .
@prefix : <https://w3id.org/valueflows-shapes#> .


vf: 
    sh:declare [
        sh:prefix "om2" ;
        sh:namespace "http://www.ontology-of-units-of-measure.org/resource/om-2/" ;
    ] ;
    sh:declare [
        sh:prefix "vf" ;
        sh:namespace "https://w3id.org/valueflows#" ;
    ] ;
    owl:imports <http://150.146.207.114/lode/extract?owlapi=true&url=https://raw.githubusercontent.com/valueflows/valueflows/master/release-doc-in-process/all_vf.TTL> ;
    owl:imports <http://www.ontology-of-units-of-measure.org/data/om-2/> ;
    .

:EconomicEventShape
        a               sh:NodeShape ;
        sh:targetClass vf:EconomicEvent ;
        sh:property :RequireProviderShape ;
        sh:property :RequireReceiverShape ;
        sh:property :ActionShape ;
        sh:property :ResourceInventoriedAsShape ;
        sh:property :ToResourceInventoriedAsShape ;
        sh:property :ResourceQuantityShape ;
        
        .

:EconomicResourceShape
        a               sh:NodeShape ;
        sh:targetClass  vf:EconomicResource ;
        sh:property     :AccountingQuantityShape ;
        sh:property     :OnhandQuantityShape ;
        sh:property     :ResourceClassifiedAsShape ;
        sh:property     :TrackingIdentifierShape ;
        sh:property     :ConformsToShape ;
        sh:property     :ContainedInShape ;
        sh:property     :CurrentLocationShape ;
        sh:property     :PrimaryAccountableShape ;
# ignoring for now:         
#       sh:property     :lotShape ; unclear: what is product batch?
#       sh:property     :stageShape ;
#       sh:property     :stateShape ;
#       sh:property     :TrackingIdentifierShape ;
    .
:PrimaryAccountableShape
        a               sh:PropertyShape ;
        sh:path         vf:primaryAccountable ;
        sh:class        foaf:Agent ;
        sh:maxCount     1 ;
        .


:CurrentLocationShape
        a               sh:PropertyShape ;
        sh:path         vf:currentLocation ;
        sh:maxCount     1 ;
        .

:ConformsToShape 
        a               sh:PropertyShape ;
        sh:path         vf:conformsTo ;
        sh:class        vf:ResourceSpecification ;
        .

:ContainedInShape
        a               sh:PropertyShape ;
        sh:path         vf:containedIn ;
        sh:class        vf:EconomicResource ;
        .

:TrackingIdentifierShape
        a               sh:PropertyShape ;
        sh:path         vf:trackingIdentifier ;
        sh:nodeKind     sh:IRIOrLiteral ;
        sh:maxCount     1 ;
        .

:ResourceClassifiedAsShape
        a               sh:PropertyShape ;
        sh:path         vf:resourceClassifiedAs ;
        sh:nodeKind     sh:IRI ;        
        .

:AccountingQuantityShape 
        a               sh:PropertyShape ;
        sh:path         vf:accountingQuantity ; 
        sh:node         :QuantityNodeShape ;
        sh:maxCount     1 ;
        sh:nodeKind     sh:BlankNodeOrIRI ;
        .

:QuantityNodeShape
        a               sh:NodeShape ;
        sh:property [
            sh:path om2:hasUnit ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path om2:hasNumericalValue ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:nodeKind sh:Literal ;
            sh:or (
                [ sh:datatype xsd:int ]
                [ sh:datatype xsd:integer ]
                [ sh:datatype xsd:double ]
                [ sh:datatype xsd:float ]
                [ sh:datatype xsd:decimal ]
                [ sh:datatype xsd:long ]
                [ sh:datatype xsd:short ]
            )
        ]
        .

:OnhandQuantityShape 
        a               sh:PropertyShape ;
        sh:node         :QuantityNodeShape ;
        sh:path         vf:onhandQuantity ;
        sh:maxCount     1 ;
        sh:nodeKind     sh:BlankNodeOrIRI ;         
        .

:ResourceQuantityShape
        a               sh:PropertyShape ;
        sh:node         :QuantityNodeShape ;
        sh:path         vf:resourceQuantity ;
        .

:ResourceInventoriedAsShape
        a               sh:PropertyShape ;
        sh:class        vf:EconomicResource ;
        sh:path         vf:resourceInventoriedAs ;
        sh:maxCount     1 ;
        .

:ToResourceInventoriedAsShape
        a               sh:PropertyShape ;
        sh:class        vf:EconomicResource ;
        sh:path         vf:toResourceInventoriedAs ;
        sh:maxCount     1 ;
        .


:RequireProviderShape
        a               sh:PropertyShape ;
        sh:path         vf:provider;
        sh:class        foaf:Agent ;
        sh:maxCount     1 ;
        sh:minCount     1 ;
        sh:nodeKind     sh:IRI ;
        .

:RequireReceiverShape
        a               sh:PropertyShape ;
        sh:path         vf:provider;
        sh:class        foaf:Agent ;
        sh:maxCount     1 ;
        sh:minCount     1 ;
        sh:nodeKind     sh:IRI ;
        .

:ActionShape
        a               sh:PropertyShape ;
        sh:path         vf:action ;
        sh:class        vf:Action ;
        sh:maxCount     1 ;
        sh:minCount     1 ;
        .      

# If an EconomicEvent references two EconomicResources, their quantities
# must be measured with the same units. (This constraint may turn out to
# be too strict - eg when splitting one big resource (measured in tons) 
# into much smaller resources (measured in kilograms). 
:RequireCompatibleQuantitiesWithoutToResourceShape
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:resourceQuantity ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:node :ToResourceInventoriedAsForbiddenShape ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:select """
                SELECT ?this ("The measurement units of this EconomicEvent and its EconomicResource do not match"  as ?message ) 
                WHERE {
                    ?this 
                        vf:resourceQuantity/om2:hasUnit                         ?evUnit  ;
                        vf:resourceInventoriedAs/vf:onhandQuantity/om2:hasUnit  ?resUnit  .     
                    FILTER (?resUnit != ?evUnit)
                }
            """ 
        ] ;
    .


# If an EconomicEvent references two EconomicResources, their quantities
# must be measured with the same units. (This constraint may turn out to
# be too strict - eg when splitting one big resource (measured in tons) 
# into much smaller resources (measured in kilograms). 
:RequireCompatibleQuantitiesWithToResourceShape
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:resourceQuantity ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:node :ToResourceInventoriedAsRequiredShape ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:select """
                SELECT ?this (CONCAT("The EconomicResources connected by this event (using ", 
                                STR(?evUnit)," for units) must use the same units of measurement for ",
                                "their vf:onhandQuantity values, but units are ", STR(?resUnit), 
                                " and ", STR(?toResUnit) ) as ?message ) 
                WHERE {
                    ?this 
                        vf:resourceQuantity/om2:hasUnit                          ?evUnit ;
                        vf:resourceInventoriedAs/vf:onhandQuantity/om2:hasUnit   ?resUnit ;     
                        vf:toResourceInventoriedAs/vf:onhandQuantity/om2:hasUnit ?toResUnit .
                    FILTER (?resUnit != ?toResUnit || ?evUnit != ?resUnit)
                }
            """ ; 
        ] ;
    .

# Some events decrement a resource's `vf:onhandQuantity`. This
# rule ensures that the resource has at least that quantity.
:RequireSufficientQuantityForResourceDecrementShape
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path ( vf:resourceQuantity om2:hasNumericalValue ) ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path ( vf:resourceInventoriedAs vf:onhandQuantity om2:hasNumericalValue );
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:select """
                SELECT ?this (CONCAT(
                    "The EconomicEvent, ", ?this, " decrements by ", ?evQuantity, 
                    ", but the EconomicResource, ", ?res, ", only has ", ?resQuantity, ".") 
                    as ?message ) 
                WHERE {
                    ?this 
                        vf:resourceQuantity/om2:hasNumericalValue 
                                        ?evQuantity ;
                        vf:resourceInventoriedAs/vf:onhandQuantity/om2:hasNumericalValue   
                                        ?resQuantity;     
                    FILTER (?resQuantity < ?evQuantity )
                }
            """ ; 
        ] ;
    .


# If an EconomicEvent references two EconomicResources, their quantities
# must be measured with the same units. (This constraint may turn out to
# be too strict - eg when splitting one big resource (measured in tons) 
# into much smaller resources (measured in kilograms). 
:RequireSameQuantitiesOnEventAndResource
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:resourceQuantity ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:node :ToResourceInventoriedAsForbiddenShape ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:select """
                SELECT ?this ("The quantities of this EconomicEvent and its EconomicResource do not match"  as ?message ) 
                WHERE {
                    ?this 
                        vf:resourceQuantity/om2:hasNumericalValue                         ?evQuantity  ;
                        vf:resourceInventoriedAs/vf:onhandQuantity/om2:hasNumericalValue  ?resQuantity  .     
                    FILTER (?resQuantity != ?evQuantity)
                }
            """ 
        ] ;
    .    

:RequireLocationChangeWithToResourceShape
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:action ; 
            sh:hasValue vf:move ; #TODO check: only with 'move' action?
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path vf:atLocation ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path ( vf:resourceInventoriedAs vf:currentLocation );
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path ( vf:toResourceInventoriedAs vf:currentLocation );
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:message "Resources/Event locations inappropriate for location change" ;
            sh:select """
                SELECT ?this 
                WHERE {
                    ?this 
                        vf:atLocation                          ?evLoc ;
                        vf:resourceInventoriedAs/vf:currentLocation ?fromLoc;     
                        vf:toResourceInventoriedAs/vf:currentLocation ?toLoc .
                    FILTER (?evLoc = ?fromLoc || ?evLoc != ?toLoc )
                }
            """ ; 
        ] ;
    .

:RequireLocationChangeWithoutToResourceShape
        a               sh:NodeShape ;
        sh:class        vf:EconomicEvent ;
        sh:property [
            sh:path vf:atLocation ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:property [
            sh:path ( vf:resourceInventoriedAs vf:currentLocation );
            sh:minCount 1 ;
            sh:maxCount 1 ;
        ] ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:message "Event's vf:atLocation must be different from resource's vf:currentLocation" ;
            sh:select """
                SELECT ?this 
                WHERE {
                    ?this 
                        vf:atLocation                          ?evLoc ;
                        vf:resourceInventoriedAs/vf:currentLocation ?fromLoc ;
                    .
                    FILTER ( ?evLoc = ?fromLoc )
                }
            """ ; 
        ] ;
    .



:ResourceInventoriedAsRequiredShape
        a           sh:NodeShape ;
        sh:property [
            sh:path vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "This event must reference an inventoried resource as its source using 'vf:resourceInventoriedAs'" ;
        ] ;
        .

:ToResourceInventoriedAsRequiredShape
        a           sh:NodeShape ;
        sh:property [
            sh:path vf:toResourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:message "This event must reference an inventoried resource as its target using 'vf:toResourceInventoriedAs'" ;
        ] ;
        .

:ToResourceInventoriedAsForbiddenShape
        a           sh:NodeShape ;
        sh:property [
            sh:path vf:toResourceInventoriedAs ;
            sh:maxCount 0 ;
            sh:message "This event must not reference an inventoried resource as its target using 'vf:toResourceInventoriedAs'" ;
        ] ;
        .

:RequireSamePrimaryAccountableShape
        a           sh:NodeShape ;
        sh:class    vf:EconomicEvent ;
        sh:node     :ToResourceInventoriedAsRequiredShape ;
        sh:sparql [
            sh:prefixes vf: ;
            sh:message "`vf:primaryAccountable` values of the resources referenced by the event must not be different." ;
            sh:select """ 
            SELECT ?this 
            WHERE {
                ?this   vf:resourceInventoriedAs ?res ;
                        vf:toResourceInventoriedAs ?toRes .
                ?res    vf:primaryAccountable   ?agent .
                ?toRes  vf:primaryAccountable   ?toAgent .
                FILTER (?agent != ?toAgent)
            }
            """;
        ] .

###############################################################################
#                   Some Utilities
###############################################################################

# SPARQLFunction for identifying EconomicEvents by properties of their vf:action
# i.e. checks if `$parEvent/vf:action/$parActionProperty = $parValue`
:EventHasActionPropertyValueFunction
        a sh:SPARQLFunction ;
        rdfs:comment "True if the specified event has an action with the specified property value" ;
        sh:labelTemplate "True for events with `vf:action/{$parActionProperty} = $parValue`. " ;
        sh:parameter [
            sh:path :parEvent ;
            sh:nodeKind sh:IRI ;
            sh:description "The event to check" ;
        ] ;
        sh:parameter [
            sh:path :parActionProperty ;
            sh:nodeKind sh:IRI ;
            sh:description "The action property to check" ;
        ] ;
        sh:parameter [
            sh:path :parValue ;
            sh:nodeKind sh:IRI ;
            sh:description "The value to compare to" ;
        ] ;
        sh:prefixes vf: ;
        sh:returnType xsd:boolean ;
        sh:ask """
            ASK  
            WHERE {
                $parEvent 
                    a                       vf:EconomicEvent ;
                    vf:action               ?action ;
                .
                ?action     
                    $parActionProperty      $parValue ;
                .
                BIND (?parEvent as ?this)
            }
        """ ;
        .


# SPARQLTargetType for selecting EconomicEvents by properties of their vf:action
# i.e. checking for [value] of [property] in event/vf:action/[property] = [value]
:EventHasActionPropertyValueTarget
        a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
        rdfs:comment "Selects events that have the specified action property value" ;
        sh:labelTemplate "All events with `vf:action/{$parActionProperty} = $parValue`. " ;
        sh:parameter [
            sh:path :parActionProperty ;
            sh:nodeKind sh:IRI ;
            sh:description "The action property to check" ;
        ] ;
        sh:parameter [
            sh:path :parValue ;
            sh:nodeKind sh:IRI ;
            sh:description "The Value to check for" ;
        ] ;
        sh:prefixes vf: ;
        sh:select """
            SELECT ?this 
            WHERE {
                ?this 
                    a                       vf:EconomicEvent ;
                    vf:action               ?action ;
                .
                ?action     
                    $parActionProperty      $parValue ;
                .
            }
        """ ;
        .

# SPARQLTarget shape for selecting current events
:CurrentEventsTargetByActionProp
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parEventActionProperty ;
            sh:nodeKind sh:IRI ;
        ] ;
        sh:parameter [
            sh:path :parEventActionPropertyValue ;
            sh:nodeKind sh:IRI ;
        ] ;         
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    ?res ;
                    vf:action                   ?action ;
                    .
                ?action 
                    ?parEventActionProperty ?parEventActionPropertyValue .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriedAs ?toRes 
                }
                FILTER NOT EXISTS {
                    ?any1 vf:previousState ?res 
                } 
			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - all events 
#   - by action
#   - that do not have a toResourceIA
:EventsWithoutToResourceTarget
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    [] ;
                .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriedAs  []               
                }
 			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - current events 
#   - by action
#   - that do not have a toResourceIA
:CurrentEventsWithoutToResourceTarget
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    ?res ;
                    vf:action                   ?parAction ;
                    .
                FILTER NOT EXISTS {
                    ?this vf:toResourceInventoriesAs []
                }
                FILTER NOT EXISTS {
                    [] vf:previousState ?res 
                } 
			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - all events 
#   - by action
#   - that have a toResourceIA
:EventsWithToResourceTarget
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    [] ;
                    vf:toResourceInventoriedAs  [] ;
                    .
 			}
			""" ;
        .

# SPARQLTarget shape for selecting 
#   - current events 
#   - by action
#   - that have a toResourceIA
:CurrentEventsWithToResourceTarget
		a sh:SPARQLTargetType ;
        rdfs:subClassOf sh:Target ;
		sh:prefixes vf: ;
        sh:parameter [
            sh:path :parAction ;
            sh:nodeKind sh:IRI ;
        ] ;
		sh:select """
			SELECT DISTINCT ?this
			WHERE {
				?this   
                    a                           vf:EconomicEvent ;
                    vf:resourceInventoriedAs    ?res ;
                    vf:toResourceInventoriedAs  ?toRes ;
                    vf:action                   ?parAction ;
                    .
                FILTER NOT EXISTS {
                    [] vf:previousState ?toRes 
                }
                FILTER NOT EXISTS {
                    [] vf:previousState ?res 
                } 
			}
			""" ;
        .

:EconomicEventHasTwoEconomicResourcesShape
    a           sh:NodeShape ;
    sh:class    vf:EconomicEvent ;
    sh:property [
        sh:path     vf:resourceInventoriedAs ;
        sh:class    vf:EconomicResource ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    sh:property [
        sh:path     vf:toResourceInventoriedAs ;
        sh:class    vf:EconomicResource ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
    ] ;
    .

###############################################################################
#                   Calculation of EcononomicEvents' effects
###############################################################################
#
# We use shape execution order 10 to start. The spec says: triples generated by 
# shapes of the same order aren't visible to each other during calculation. We 
# use this to calculate the different kinds of effects (quantity, location, 
# primaryAccountable)

# An EconomicResource can only be connected with a new EconomicEvent
# if the resource is the head of the chain formed by vf:previousState
# relationships.
:EconomicResourceChainHeadShape
        a           sh:NodeShape ;
        sh:property [
            sh:path (sh:inversePath vf:previousState ) ;
            sh:maxCount 0 ;
        ] ;
        sh:rule [
            a sh:TripleRule ;
            sh:subject sh:this ;
            sh:predicate rdf:type ;
            sh:object vf:ChainHeadDebug ;
        ]
        .

# An EconomicEvent is current if it references EconomicResources that 
# are the heads of their respective state chains. We only calculate effects
# for current events 
:CurrentEventShape
        a               sh:NodeShape ;
        sh:order 0 ;
        sh:targetClass vf:EconomicEvent ;
        sh:property [
            sh:path vf:resourceInventoriedAs ;
            sh:minCount 1 ;
            sh:maxCount 1 ;
            sh:node :EconomicResourceChainHeadShape ;
        ] ;
        sh:property [
            sh:path vf:toResourceInventoriedAs ;
            sh:maxCount 1 ;
            sh:node :EconomicResourceChainHeadShape ;
        ] 
        .

###############################################################################
#                       Events with action `vf:move` 
###############################################################################

## `vf:move` connected to only one resource

# Rules specific for move actions with `vf:resourceInventoriedAs` and NO `vf:toResourceInventoriedAs`:
# - The event must have different `vf:atLocation` value than the resource's `vf:currentLocation` 
# - The event must have a quantity that must be equal to the resource's quantity
:MoveActionWithoutToResourceShape
        a           sh:NodeShape ;
        sh:target [
            a :EventsWithoutToResourceTarget ;
            :parAction vf:move
        ] ;
        sh:node :RequireLocationChangeWithoutToResourceShape ;
        sh:node :RequireSameQuantitiesOnEventAndResource;
       .


# Effect of a current `move` action that has a 
#    `vf:resourceInventoriedAs` and NO
#    `vf:toResourceInventoriedAs` :
# 
# - It generates one new resource states for `resource`
# - It copies all old values but changes the location to the event's location
#
# Note: there are problems with finding a boundary for the query so it can recurse in the star-shaped 
#       environment of the resource, but it does not go to far. 
:MoveEventWithoutToResourceEffectsShape
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsWithoutToResourceTarget ;
            :parAction vf:move
        ] ;
        sh:node :CurrentEventShape ;
        sh:rule [
            a sh:SPARQLRule ;
            sh:prefixes vf: ;
            sh:construct """
                CONSTRUCT {
                    ?next vf:previousState ?res .
                    ?next vf:currentLocation ?evLocation . #problem: deeper structures!
                    ?evLocation ?lp2 ?lo2 .
                    ?lo2 ?lp3 ?lo3 .
                    ?next ?p ?o .
                    ?o ?p2 ?o2 .
                    ?o2 ?p3 ?o3 .
                } WHERE {
                    ?this vf:resourceInventoriedAs ?res .
                    {
                        {
                                # generate an IRI and a bnode that's the same in ALL solutions
                                SELECT 
                                    (UUID() as ?next) (BNODE() as ?onhandQuantity) 
                                    (UUID() as ?toNext) (BNODE() as ?toOnhandQuantity) 
                                WHERE { }
                        }
                        {
                            ?res ?p ?o .
                            FILTER (
                                ?p != vf:currentLocation
                            )
                            OPTIONAL {
                                ?o ?p2 ?o2
                                FILTER (!ISIRI(?o) ||!STRSTARTS(STR(?o), "https://w3id.org/valueflows"))
                                FILTER (!ISIRI(?o) ||!STRSTARTS(STR(?o), "http://www.ontology-of-units-of-measure.org/resource/om-2/"))
                                OPTIONAL {
                                    ?o2 ?p3 ?o3 .
                                    FILTER (!ISIRI(?o2) || !STRSTARTS(STR(?o2), "https://w3id.org/valueflows"))
                                    FILTER (!ISIRI(?o2) || !STRSTARTS(STR(?o2), "http://www.ontology-of-units-of-measure.org/resource/om-2/"))
                                }
                            }
                        } UNION {
                            ?this vf:atLocation ?evLocation 
                            OPTIONAL {
                                ?evLocation ?lp2 ?lo2
                                OPTIONAL {
                                    ?lo2 ?lp3 ?lo3 .
                                    FILTER NOT EXISTS {
                                        ?lo2 ?lp3 ?lo3 .
                                        FILTER (!ISIRI(?lo2) || !STRSTARTS(STR(?lo2), "https://w3id.org/valueflows"))
                                        FILTER (!ISIRI(?lo2) || !STRSTARTS(STR(?lo2), "http://www.ontology-of-units-of-measure.org/resource/om-2/"))
                                    }
                                }
                            }

                        }

                    }
                }""" ;
            ] ;
        .


## `vf:move` connected to two resources


# Rules specific for move actions with `vf:resourceInventoriedAs` and `vf:toResourceInventoriedAs`:
# - The two resources must have different `vf:currentLocation` values
# - The toResource must have the same `vf:currentLocation` as the event's `vf:atLocation`
# - The two resources must have identical `vf:onhandQuantity/om2:hasUnit` values
# - The two resources must have the same `vf:primaryAccountable`
# - The action's `vf:resourceQuantity/vf:om2:hasNumericalValue` must be larger than 
#   the resource's `vf:onhandQuantity`
:MoveActionWithToResourceShape
        a           sh:NodeShape ;
        sh:target [
            a :EventsWithToResourceTarget ;
            :parAction vf:move
        ] ;
        sh:node :RequireLocationChangeWithToResourceShape ;
        sh:node :RequireCompatibleQuantitiesWithToResourceShape ; 
        sh:node :RequireSamePrimaryAccountableShape ;        
        sh:node :RequireSufficientQuantityForResourceDecrementShape ;
        .

# Effect of a current `move` action that has a 
#    `vf:resourceInventoriedAs` and a
#    `vf:toResourceInventoriedAs` :
# 
# It generates new resource states for `resource` and `toResource`
#   - sets both `vf:onhandQuantity` based on the event `vf:resourceQuantity`
# 

:MoveEventWithToResourceEffectsShape
        a           sh:NodeShape ;
        sh:target [
            a :CurrentEventsWithToResourceTarget ;
            :parAction vf:move
        ] ;
        sh:node :CurrentEventShape ;
        sh:rule [
            a sh:SPARQLRule ;
            sh:prefixes vf: ;
            sh:construct """
                CONSTRUCT {
                    ?next vf:previousState ?res .
                    ?next ?p ?o .
                    ?next vf:onhandQuantity ?onhandQuantity .
                    ?onhandQuantity om2:hasUnit ?onhandUnit .
                    ?onhandQuantity om2:hasNumericalValue ?newOnhandValue .

                    ?toNext vf:previousState ?toRes .
                    ?toNext ?toP ?toO .
                    ?toNext vf:onhandQuantity ?toOnhandQuantity .
                    ?toOnhandQuantity om2:hasUnit ?toOnhandUnit .
                    ?toOnhandQuantity om2:hasNumericalValue ?toNewOnhandValue .
                } WHERE {
                    ?this vf:resourceInventoriedAs ?res .
                    ?this vf:toResourceInventoriedAs ?toRes .
                    {
                        {
                                # generate an IRI and a bnode that's the same in ALL solutions
                                SELECT 
                                    (UUID() as ?next) (BNODE() as ?onhandQuantity) 
                                    (UUID() as ?toNext) (BNODE() as ?toOnhandQuantity) 
                                WHERE { }
                        }
                        {
                            ?res ?p ?o .
                            FILTER (
                                ?p != vf:onhandQuantity 
                                && ?p != vf:accountingQuantity 
                            )
                        } UNION {
                            ?toRes ?toP ?toO .
                            FILTER (
                                ?toP != vf:onhandQuantity 
                                && ?toP != vf:accountingQuantity 
                            )
                        } UNION {
                            ?this vf:resourceQuantity/om2:hasNumericalValue ?eventValue .
                            ?res vf:onhandQuantity [
                                om2:hasUnit ?onhandUnit ;
                                om2:hasNumericalValue ?onhandValue ;
                            ] .
                            ?toRes vf:onhandQuantity [
                                om2:hasUnit ?toOnhandUnit ;
                                om2:hasNumericalValue ?toOnhandValue ;
                            ] .
                            BIND (?onhandValue - ?eventValue as ?newOnhandValue)
                            BIND (?toOnhandValue + ?eventValue as ?toNewOnhandValue)
                        }
                    }
                }""" ;
            ] ;
        .